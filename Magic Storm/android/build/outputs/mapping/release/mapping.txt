# compiler: R8
# compiler_version: 3.2.47
# min_api: 14
# common_typos_disable
# {"id":"com.android.tools.r8.mapping","version":"2.0"}
# pg_map_id: 852cf4f
# pg_map_hash: SHA-256 852cf4fb13b96893290966bbfbc2abf7b9448c3002023192fcd955b5fc347540
com.badlogic.gdx.AbstractGraphics -> a.a:
com.badlogic.gdx.AbstractInput -> a.b:
    com.badlogic.gdx.utils.IntSet keysToCatch -> c
    boolean[] pressedKeys -> a
    boolean keyJustPressed -> e
    boolean[] justPressedKeys -> b
    int pressedKeyCount -> d
    boolean isKeyPressed(int) -> e
    boolean isCatchKey(int) -> j
    void setCatchKey(int,boolean) -> k
com.badlogic.gdx.Application -> a.c:
    com.badlogic.gdx.Application$ApplicationType getType() -> f
    void log(java.lang.String,java.lang.String,java.lang.Throwable) -> g
    void error(java.lang.String,java.lang.String) -> h
    void log(java.lang.String,java.lang.String) -> i
    com.badlogic.gdx.Graphics getGraphics() -> j
    void addLifecycleListener(com.badlogic.gdx.LifecycleListener) -> k
    com.badlogic.gdx.ApplicationListener getApplicationListener() -> l
    void postRunnable(java.lang.Runnable) -> m
    void removeLifecycleListener(com.badlogic.gdx.LifecycleListener) -> n
com.badlogic.gdx.Application$ApplicationType -> a.c$a:
    com.badlogic.gdx.Application$ApplicationType Android -> a
    com.badlogic.gdx.Application$ApplicationType HeadlessDesktop -> c
    com.badlogic.gdx.Application$ApplicationType Desktop -> b
    com.badlogic.gdx.Application$ApplicationType[] $VALUES -> g
    com.badlogic.gdx.Application$ApplicationType WebGL -> e
    com.badlogic.gdx.Application$ApplicationType Applet -> d
    com.badlogic.gdx.Application$ApplicationType iOS -> f
com.badlogic.gdx.ApplicationListener -> a.d:
    void dispose() -> a
    void resume() -> b
    void pause() -> c
    void resize(int,int) -> d
    void create() -> e
    void render() -> f
com.badlogic.gdx.ApplicationLogger -> a.e:
    void log(java.lang.String,java.lang.String,java.lang.Throwable) -> g
    void error(java.lang.String,java.lang.String) -> h
    void log(java.lang.String,java.lang.String) -> i
com.badlogic.gdx.Audio -> a.f:
com.badlogic.gdx.Files -> a.g:
    com.badlogic.gdx.files.FileHandle classpath(java.lang.String) -> a
    com.badlogic.gdx.files.FileHandle internal(java.lang.String) -> b
    java.lang.String getLocalStoragePath() -> c
    java.lang.String getExternalStoragePath() -> d
    com.badlogic.gdx.files.FileHandle getFileHandle(java.lang.String,com.badlogic.gdx.Files$FileType) -> e
com.badlogic.gdx.Files$FileType -> a.g$a:
    com.badlogic.gdx.Files$FileType[] $VALUES -> f
    com.badlogic.gdx.Files$FileType Local -> e
    com.badlogic.gdx.Files$FileType Absolute -> d
    com.badlogic.gdx.Files$FileType External -> c
    com.badlogic.gdx.Files$FileType Internal -> b
    com.badlogic.gdx.Files$FileType Classpath -> a
com.badlogic.gdx.Game -> a.h:
    com.badlogic.gdx.Screen screen -> a
    void resume() -> b
    void pause() -> c
    void resize(int,int) -> d
    void render() -> f
    com.badlogic.gdx.Screen getScreen() -> g
    void setScreen(com.badlogic.gdx.Screen) -> h
com.badlogic.gdx.Gdx -> a.i:
    com.badlogic.gdx.Files files -> e
    com.badlogic.gdx.graphics.GL30 gl30 -> i
    com.badlogic.gdx.graphics.GL20 gl20 -> h
    com.badlogic.gdx.graphics.GL20 gl -> g
    com.badlogic.gdx.Graphics graphics -> b
    com.badlogic.gdx.Net net -> f
    com.badlogic.gdx.Application app -> a
    com.badlogic.gdx.Audio audio -> c
    com.badlogic.gdx.Input input -> d
com.badlogic.gdx.Graphics -> a.j:
    int getWidth() -> b
    int getHeight() -> c
    boolean isGL30Available() -> d
    int getBackBufferHeight() -> e
    int getBackBufferWidth() -> f
    boolean supportsExtension(java.lang.String) -> g
    com.badlogic.gdx.Graphics$DisplayMode getDisplayMode() -> h
    void setContinuousRendering(boolean) -> i
    void requestRendering() -> j
    float getDeltaTime() -> k
com.badlogic.gdx.Graphics$BufferFormat -> a.j$a:
    int stencil -> f
    int samples -> g
    int a -> d
    int depth -> e
    boolean coverageSampling -> h
    int g -> b
    int b -> c
    int r -> a
com.badlogic.gdx.Graphics$DisplayMode -> a.j$b:
    int bitsPerPixel -> d
    int height -> b
    int refreshRate -> c
    int width -> a
com.badlogic.gdx.Input -> a.k:
    boolean isTouched() -> a
    boolean isKeyPressed(int) -> e
    void setInputProcessor(com.badlogic.gdx.InputProcessor) -> f
    int getX() -> g
    int getY() -> i
com.badlogic.gdx.Input$OnscreenKeyboardType -> a.k$a:
    com.badlogic.gdx.Input$OnscreenKeyboardType Default -> a
    com.badlogic.gdx.Input$OnscreenKeyboardType URI -> f
    com.badlogic.gdx.Input$OnscreenKeyboardType PhonePad -> c
    com.badlogic.gdx.Input$OnscreenKeyboardType NumberPad -> b
    com.badlogic.gdx.Input$OnscreenKeyboardType[] $VALUES -> g
    com.badlogic.gdx.Input$OnscreenKeyboardType Password -> e
    com.badlogic.gdx.Input$OnscreenKeyboardType Email -> d
com.badlogic.gdx.Input$Orientation -> a.k$b:
    com.badlogic.gdx.Input$Orientation Landscape -> a
    com.badlogic.gdx.Input$Orientation[] $VALUES -> c
    com.badlogic.gdx.Input$Orientation Portrait -> b
com.badlogic.gdx.InputAdapter -> a.l:
com.badlogic.gdx.InputProcessor -> a.m:
    boolean touchDragged(int,int,int) -> A
    boolean mouseMoved(int,int) -> H
    boolean keyUp(int) -> K
    boolean touchUp(int,int,int,int) -> M
    boolean scrolled(float,float) -> j
    boolean keyTyped(char) -> n
    boolean keyDown(int) -> s
    boolean touchDown(int,int,int,int) -> u
com.badlogic.gdx.LifecycleListener -> a.n:
    void dispose() -> a
    void resume() -> b
    void pause() -> c
com.badlogic.gdx.Net -> a.o:
com.badlogic.gdx.Screen -> a.p:
    void render(float) -> a
    void resume() -> b
    void pause() -> c
    void resize(int,int) -> d
    void hide() -> e
    void show() -> f
com.badlogic.gdx.audio.Music -> b.a:
com.badlogic.gdx.audio.Music$OnCompletionListener -> b.a$a:
    void onCompletion(com.badlogic.gdx.audio.Music) -> a
com.badlogic.gdx.backends.android.AndroidApplication -> c.a:
    int logLevel -> n
    com.badlogic.gdx.backends.android.AndroidNet net -> e
    boolean useImmersiveMode -> p
    boolean firstResume -> i
    com.badlogic.gdx.backends.android.AndroidInput input -> b
    com.badlogic.gdx.utils.SnapshotArray lifecycleListeners -> l
    com.badlogic.gdx.backends.android.AndroidFiles files -> d
    com.badlogic.gdx.backends.android.AndroidAudio audio -> c
    boolean isWaitingForAudio -> r
    com.badlogic.gdx.utils.Array androidEventListeners -> m
    com.badlogic.gdx.ApplicationLogger applicationLogger -> o
    com.badlogic.gdx.utils.Array executedRunnables -> k
    com.badlogic.gdx.utils.Array runnables -> j
    com.badlogic.gdx.ApplicationListener listener -> g
    com.badlogic.gdx.backends.android.AndroidClipboard clipboard -> f
    com.badlogic.gdx.backends.android.AndroidGraphics graphics -> a
    android.os.Handler handler -> h
    int wasFocusChanged -> q
    void init(com.badlogic.gdx.ApplicationListener,com.badlogic.gdx.backends.android.AndroidApplicationConfiguration,boolean) -> A
    void initialize(com.badlogic.gdx.ApplicationListener,com.badlogic.gdx.backends.android.AndroidApplicationConfiguration) -> B
    void setApplicationLogger(com.badlogic.gdx.ApplicationLogger) -> C
    com.badlogic.gdx.utils.Array getExecutedRunnables() -> a
    void useImmersiveMode(boolean) -> b
    com.badlogic.gdx.utils.Array getRunnables() -> c
    android.content.Context getContext() -> d
    android.view.Window getApplicationWindow() -> e
    com.badlogic.gdx.Application$ApplicationType getType() -> f
    void log(java.lang.String,java.lang.String,java.lang.Throwable) -> g
    void error(java.lang.String,java.lang.String) -> h
    void log(java.lang.String,java.lang.String) -> i
    com.badlogic.gdx.Graphics getGraphics() -> j
    void addLifecycleListener(com.badlogic.gdx.LifecycleListener) -> k
    com.badlogic.gdx.ApplicationListener getApplicationListener() -> l
    void postRunnable(java.lang.Runnable) -> m
    void removeLifecycleListener(com.badlogic.gdx.LifecycleListener) -> n
    com.badlogic.gdx.backends.android.AndroidInput getInput() -> o
    com.badlogic.gdx.utils.SnapshotArray getLifecycleListeners() -> p
    com.badlogic.gdx.backends.android.AndroidAudio createAudio(android.content.Context,com.badlogic.gdx.backends.android.AndroidApplicationConfiguration) -> q
    com.badlogic.gdx.backends.android.AndroidFiles createFiles() -> r
    com.badlogic.gdx.backends.android.AndroidInput createInput(com.badlogic.gdx.Application,android.content.Context,java.lang.Object,com.badlogic.gdx.backends.android.AndroidApplicationConfiguration) -> s
    android.widget.FrameLayout$LayoutParams createLayoutParams() -> t
    void createWakeLock(boolean) -> u
    com.badlogic.gdx.ApplicationLogger getApplicationLogger() -> v
    com.badlogic.gdx.Audio getAudio() -> w
    com.badlogic.gdx.Files getFiles() -> x
    com.badlogic.gdx.Net getNet() -> y
    int getVersion() -> z
com.badlogic.gdx.backends.android.AndroidApplication$1 -> c.a$a:
    com.badlogic.gdx.backends.android.AndroidApplication this$0 -> a
    void dispose() -> a
    void resume() -> b
    void pause() -> c
com.badlogic.gdx.backends.android.AndroidApplicationBase -> c.b:
    com.badlogic.gdx.utils.Array getExecutedRunnables() -> a
    void useImmersiveMode(boolean) -> b
    com.badlogic.gdx.utils.Array getRunnables() -> c
    android.content.Context getContext() -> d
    android.view.Window getApplicationWindow() -> e
    com.badlogic.gdx.backends.android.AndroidInput getInput() -> o
    com.badlogic.gdx.utils.SnapshotArray getLifecycleListeners() -> p
com.badlogic.gdx.backends.android.AndroidApplicationConfiguration -> c.c:
    boolean useWakelock -> n
    int sensorDelay -> l
    boolean disableAudio -> o
    int touchSleepTime -> m
    boolean useGyroscope -> i
    boolean useCompass -> j
    boolean useRotationVectorSensor -> k
    int stencil -> f
    int numSamples -> g
    int a -> d
    int depth -> e
    int g -> b
    int b -> c
    boolean getTouchEventsForLiveWallpaper -> r
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy resolutionStrategy -> q
    boolean useImmersiveMode -> s
    int r -> a
    boolean useGL30 -> t
    boolean useAccelerometer -> h
    int maxNetThreads -> u
    int maxSimultaneousSounds -> p
com.badlogic.gdx.backends.android.AndroidApplicationLogger -> c.d:
    void log(java.lang.String,java.lang.String,java.lang.Throwable) -> g
    void error(java.lang.String,java.lang.String) -> h
    void log(java.lang.String,java.lang.String) -> i
com.badlogic.gdx.backends.android.AndroidAudio -> c.e:
    void resume() -> b
    void pause() -> c
    void notifyMusicDisposed(com.badlogic.gdx.backends.android.AndroidMusic) -> y
com.badlogic.gdx.backends.android.AndroidClipboard -> c.f:
    android.content.ClipboardManager clipboard -> a
com.badlogic.gdx.backends.android.AndroidEventListener -> c.g:
    void onActivityResult(int,int,android.content.Intent) -> a
com.badlogic.gdx.backends.android.AndroidFileHandle -> c.h:
    android.content.res.AssetManager assets -> c
    com.badlogic.gdx.files.FileHandle child(java.lang.String) -> a
    boolean exists() -> c
    java.io.File file() -> e
    long length() -> f
    com.badlogic.gdx.files.FileHandle parent() -> i
    java.io.InputStream read() -> k
    com.badlogic.gdx.files.FileHandle sibling(java.lang.String) -> n
com.badlogic.gdx.backends.android.AndroidFiles -> c.i:
com.badlogic.gdx.backends.android.AndroidGL20 -> c.j:
    int[] ints2 -> b
    int[] ints3 -> c
    int[] ints -> a
    byte[] buffer -> d
    void glDrawElements(int,int,int,int) -> A
    int glGenFramebuffer() -> B
    java.lang.String glGetProgramInfoLog(int) -> C
    void glEnableVertexAttribArray(int) -> E
    java.lang.String glGetString(int) -> F
    void glClear(int) -> G
    void glUniform1i(int,int) -> H
    void glTexParameteri(int,int,int) -> I
    void glBindBuffer(int,int) -> J
    void glBufferData(int,int,java.nio.Buffer,int) -> L
    void glCompressedTexImage2D(int,int,int,int,int,int,int,java.nio.Buffer) -> M
    int glGetUniformLocation(int,java.lang.String) -> N
    void glDisable(int) -> O
    void glVertexAttribPointer(int,int,int,boolean,int,int) -> P
    int glGetAttribLocation(int,java.lang.String) -> Q
    void glPixelStorei(int,int) -> R
    java.lang.String glGetActiveAttrib(int,int,java.nio.IntBuffer,java.nio.IntBuffer) -> S
    void glDepthMask(boolean) -> T
    void glScissor(int,int,int,int) -> U
    void glDisableVertexAttribArray(int) -> V
    void glClearColor(float,float,float,float) -> W
    int glCreateShader(int) -> X
    void glDeleteTexture(int) -> Z
    void glEnable(int) -> a
    void glGetIntegerv(int,java.nio.IntBuffer) -> a0
    int glGenBuffer() -> b
    void glBindTexture(int,int) -> b0
    void glBindFramebuffer(int,int) -> c
    void glDeleteShader(int) -> c0
    void glDeleteProgram(int) -> d0
    void glCompileShader(int) -> e0
    void glDrawArrays(int,int,int) -> f
    void glDeleteBuffer(int) -> f0
    void glUniformMatrix4fv(int,int,boolean,float[],int) -> g
    void glGetShaderiv(int,int,java.nio.IntBuffer) -> g0
    void glVertexAttribPointer(int,int,int,boolean,int,java.nio.Buffer) -> h
    void glGetFloatv(int,java.nio.FloatBuffer) -> i
    void glViewport(int,int,int,int) -> j
    void glShaderSource(int,java.lang.String) -> k
    void glAttachShader(int,int) -> l
    void glTexParameterf(int,int,float) -> m
    java.lang.String glGetActiveUniform(int,int,java.nio.IntBuffer,java.nio.IntBuffer) -> n
    void glUseProgram(int) -> o
    void glGenerateMipmap(int) -> p
    void glGetProgramiv(int,int,java.nio.IntBuffer) -> q
    void glLinkProgram(int) -> r
    void glBufferSubData(int,int,int,java.nio.Buffer) -> s
    java.lang.String glGetShaderInfoLog(int) -> t
    void glDrawElements(int,int,int,java.nio.Buffer) -> v
    void glTexImage2D(int,int,int,int,int,int,int,int,java.nio.Buffer) -> w
    int glGenTexture() -> x
    int glCreateProgram() -> y
    void glBlendFuncSeparate(int,int,int,int) -> z
com.badlogic.gdx.backends.android.AndroidGL30 -> c.k:
    void glDeleteVertexArrays(int,java.nio.IntBuffer) -> D
    void glGenVertexArrays(int,java.nio.IntBuffer) -> K
    void glBindVertexArray(int) -> Y
    void glDrawArraysInstanced(int,int,int,int) -> d
    void glTexImage3D(int,int,int,int,int,int,int,int,int,java.nio.Buffer) -> e
    void glDrawElementsInstanced(int,int,int,int,int) -> u
com.badlogic.gdx.backends.android.AndroidGraphics -> c.l:
    com.badlogic.gdx.graphics.GL30 gl30 -> j
    com.badlogic.gdx.graphics.GL20 gl20 -> i
    int safeInsetBottom -> f
    boolean running -> u
    int safeInsetLeft -> d
    boolean resume -> w
    float ppcY -> B
    com.badlogic.gdx.Graphics$BufferFormat bufferFormat -> E
    int width -> b
    com.badlogic.gdx.graphics.glutils.GLVersion glVersion -> l
    int[] value -> G
    float ppiX -> y
    com.badlogic.gdx.backends.android.AndroidApplicationBase app -> h
    com.badlogic.gdx.backends.android.AndroidApplicationConfiguration config -> D
    long frameId -> q
    float deltaTime -> o
    int fps -> s
    java.lang.Object synch -> H
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20 view -> a
    boolean enforceContinuousRendering -> I
    java.lang.String extensions -> m
    int safeInsetRight -> g
    boolean pause -> v
    float density -> C
    int safeInsetTop -> e
    boolean destroy -> x
    float ppcX -> A
    int height -> c
    boolean created -> t
    float ppiY -> z
    javax.microedition.khronos.egl.EGLContext eglContext -> k
    boolean isContinuous -> F
    long lastFrameTime -> n
    int frames -> r
    long frameStart -> p
    void updatePpi() -> A
    void updateSafeAreaInsets() -> B
    boolean checkGL20() -> a
    int getWidth() -> b
    int getHeight() -> c
    boolean isGL30Available() -> d
    int getBackBufferHeight() -> e
    int getBackBufferWidth() -> f
    boolean supportsExtension(java.lang.String) -> g
    com.badlogic.gdx.Graphics$DisplayMode getDisplayMode() -> h
    void setContinuousRendering(boolean) -> i
    void requestRendering() -> j
    float getDeltaTime() -> k
    void clearManagedCaches() -> l
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20 createGLSurfaceView(com.badlogic.gdx.backends.android.AndroidApplicationBase,com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy) -> m
    void destroy() -> n
    int getAttrib(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,int,int) -> o
    android.opengl.GLSurfaceView$EGLConfigChooser getEglConfigChooser() -> p
    android.view.View getView() -> q
    boolean isContinuousRendering() -> r
    void logConfig(javax.microedition.khronos.egl.EGLConfig) -> s
    void logManagedCachesStatus() -> t
    void onPauseGLSurfaceView() -> u
    void onResumeGLSurfaceView() -> v
    void pause() -> w
    void preserveEGLContextOnPause() -> x
    void resume() -> y
    void setupGL(javax.microedition.khronos.opengles.GL10) -> z
com.badlogic.gdx.backends.android.AndroidGraphics$1 -> c.l$a:
    com.badlogic.gdx.backends.android.AndroidGraphics this$0 -> a
com.badlogic.gdx.backends.android.AndroidGraphics$AndroidDisplayMode -> c.l$b:
    com.badlogic.gdx.backends.android.AndroidGraphics this$0 -> e
com.badlogic.gdx.backends.android.AndroidInput -> c.m:
    void onPause() -> b
    void processEvents() -> c
    void onResume() -> d
    void setKeyboardAvailable(boolean) -> h
com.badlogic.gdx.backends.android.AndroidMouseHandler -> c.n:
    int deltaY -> b
    int deltaX -> a
    boolean onGenericMotion(android.view.MotionEvent,com.badlogic.gdx.backends.android.DefaultAndroidInput) -> a
    void postTouchEvent(com.badlogic.gdx.backends.android.DefaultAndroidInput,int,int,int,int,int,long) -> b
com.badlogic.gdx.backends.android.AndroidMusic -> c.o:
    com.badlogic.gdx.backends.android.AndroidAudio audio -> a
    com.badlogic.gdx.audio.Music$OnCompletionListener onCompletionListener -> e
    android.media.MediaPlayer player -> b
    boolean isPrepared -> c
    boolean wasPlaying -> d
    void dispose() -> a
    void pause() -> c
    boolean isPlaying() -> j
    void play() -> n
com.badlogic.gdx.backends.android.AndroidMusic$1 -> c.o$a:
    com.badlogic.gdx.backends.android.AndroidMusic this$0 -> a
com.badlogic.gdx.backends.android.AndroidNet -> c.p:
    com.badlogic.gdx.net.NetJavaImpl netJavaImpl -> b
    com.badlogic.gdx.backends.android.AndroidApplicationBase app -> a
com.badlogic.gdx.backends.android.AndroidTouchHandler -> c.q:
    void onTouch(android.view.MotionEvent,com.badlogic.gdx.backends.android.DefaultAndroidInput) -> a
    void postTouchEvent(com.badlogic.gdx.backends.android.DefaultAndroidInput,int,int,int,int,int,long) -> b
    boolean supportsMultitouch(android.content.Context) -> c
    int toGdxButton(int) -> d
com.badlogic.gdx.backends.android.AndroidVisibilityListener -> c.r:
    void createListener(com.badlogic.gdx.backends.android.AndroidApplicationBase) -> a
com.badlogic.gdx.backends.android.AndroidVisibilityListener$1 -> c.r$a:
    com.badlogic.gdx.backends.android.AndroidVisibilityListener this$0 -> b
    com.badlogic.gdx.backends.android.AndroidApplicationBase val$application -> a
com.badlogic.gdx.backends.android.AndroidVisibilityListener$1$1 -> c.r$a$a:
    com.badlogic.gdx.backends.android.AndroidVisibilityListener$1 this$1 -> a
com.badlogic.gdx.backends.android.DefaultAndroidAudio -> c.s:
    android.media.AudioManager manager -> b
    android.media.SoundPool soundPool -> a
    java.util.List musics -> c
    void dispose() -> a
    void resume() -> b
    void pause() -> c
    void notifyMusicDisposed(com.badlogic.gdx.backends.android.AndroidMusic) -> y
com.badlogic.gdx.backends.android.DefaultAndroidFiles -> c.t:
    android.content.res.AssetManager assets -> c
    java.lang.String externalFilesPath -> a
    java.lang.String localpath -> b
    com.badlogic.gdx.files.FileHandle classpath(java.lang.String) -> a
    com.badlogic.gdx.files.FileHandle internal(java.lang.String) -> b
    java.lang.String getLocalStoragePath() -> c
    java.lang.String getExternalStoragePath() -> d
    com.badlogic.gdx.files.FileHandle getFileHandle(java.lang.String,com.badlogic.gdx.Files$FileType) -> e
    java.lang.String initExternalFilesPath(android.content.ContextWrapper) -> f
com.badlogic.gdx.backends.android.DefaultAndroidInput -> c.u:
    float pitch -> L
    boolean justTouched -> N
    android.content.Context context -> B
    float[] magneticFieldValues -> I
    boolean[] touched -> o
    android.hardware.SensorEventListener accelerometerListener -> S
    boolean hasMultitouch -> s
    android.hardware.SensorEventListener compassListener -> U
    com.badlogic.gdx.backends.android.AndroidApplicationConfiguration config -> P
    java.util.ArrayList keyEvents -> i
    int[] deltaY -> n
    long currentEventTimeStamp -> R
    int[] button -> p
    boolean rotationVectorAvailable -> G
    com.badlogic.gdx.Input$Orientation nativeOrientation -> Q
    com.badlogic.gdx.utils.Pool usedKeyEvents -> f
    float[] pressure -> r
    com.badlogic.gdx.backends.android.AndroidMouseHandler mouseHandler -> X
    int[] touchY -> l
    android.hardware.SensorEventListener rotationVectorListener -> V
    float azimuth -> K
    float[] rotationVectorValues -> J
    boolean[] justPressedButtons -> t
    android.os.Vibrator vibrator -> E
    com.badlogic.gdx.backends.android.AndroidTouchHandler touchHandler -> C
    boolean accelerometerAvailable -> v
    int sleepTime -> D
    boolean gyroscopeAvailable -> x
    com.badlogic.gdx.Application app -> A
    android.os.Handler handle -> z
    com.badlogic.gdx.InputProcessor processor -> O
    android.hardware.SensorEventListener gyroscopeListener -> T
    float[] gyroscopeValues -> y
    boolean requestFocus -> Y
    java.util.ArrayList touchEvents -> j
    float[] R -> Z
    float[] accelerometerValues -> w
    java.util.ArrayList keyListeners -> h
    java.util.ArrayList genericMotionListeners -> W
    android.hardware.SensorManager manager -> u
    boolean compassAvailable -> F
    int[] realId -> q
    boolean keyboardAvailable -> H
    int[] touchX -> k
    float[] orientation -> a0
    com.badlogic.gdx.utils.Pool usedTouchEvents -> g
    int[] deltaX -> m
    float roll -> M
    boolean isTouched() -> a
    void onPause() -> b
    void processEvents() -> c
    void onResume() -> d
    void setInputProcessor(com.badlogic.gdx.InputProcessor) -> f
    int getX() -> g
    void setKeyboardAvailable(boolean) -> h
    int getY() -> i
    int getAndroidInputType(com.badlogic.gdx.Input$OnscreenKeyboardType) -> l
    int getFreePointerIndex() -> m
    int getRotation() -> n
    int lookUpPointerIndex(int) -> o
    void registerSensorListeners() -> p
    float[] resize(float[]) -> q
    int[] resize(int[]) -> r
    boolean[] resize(boolean[]) -> s
    void unregisterSensorListeners() -> t
com.badlogic.gdx.backends.android.DefaultAndroidInput$1 -> c.u$a:
    com.badlogic.gdx.backends.android.DefaultAndroidInput this$0 -> d
    java.lang.Object newObject() -> d
    com.badlogic.gdx.backends.android.DefaultAndroidInput$KeyEvent newObject() -> g
com.badlogic.gdx.backends.android.DefaultAndroidInput$2 -> c.u$b:
    com.badlogic.gdx.backends.android.DefaultAndroidInput this$0 -> d
    java.lang.Object newObject() -> d
    com.badlogic.gdx.backends.android.DefaultAndroidInput$TouchEvent newObject() -> g
com.badlogic.gdx.backends.android.DefaultAndroidInput$5 -> c.u$c:
    int[] $SwitchMap$com$badlogic$gdx$Input$OnscreenKeyboardType -> a
com.badlogic.gdx.backends.android.DefaultAndroidInput$KeyEvent -> c.u$d:
    long timeStamp -> a
    int type -> b
    char keyChar -> d
    int keyCode -> c
com.badlogic.gdx.backends.android.DefaultAndroidInput$SensorListener -> c.u$e:
    com.badlogic.gdx.backends.android.DefaultAndroidInput this$0 -> a
com.badlogic.gdx.backends.android.DefaultAndroidInput$TouchEvent -> c.u$f:
    int pointer -> h
    int scrollAmountY -> f
    long timeStamp -> a
    int button -> g
    int y -> d
    int scrollAmountX -> e
    int type -> b
    int x -> c
com.badlogic.gdx.backends.android.surfaceview.FillResolutionStrategy -> d.a:
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy$MeasuredDimension calcMeasures(int,int) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20 -> d.b:
    int targetGLESVersion -> d
    java.lang.String TAG -> c
    com.badlogic.gdx.Input$OnscreenKeyboardType onscreenKeyboardType -> b
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy resolutionStrategy -> a
    boolean checkEglError(java.lang.String,javax.microedition.khronos.egl.EGL10) -> a
    void init(boolean,int,int) -> b
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20$1 -> d.b$a:
    com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20 this$0 -> a
    void sendDownUpKeyEventForBackwardCompatibility(int) -> a
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20$ConfigChooser -> d.b$b:
    int[] mValue -> g
    int[] s_configAttribs2 -> h
    int mStencilSize -> f
    int mAlphaSize -> d
    int mDepthSize -> e
    int mGreenSize -> b
    int mBlueSize -> c
    int mRedSize -> a
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig[]) -> a
    int findConfigAttrib(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,int,int) -> b
com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20$ContextFactory -> d.b$c:
    int EGL_CONTEXT_CLIENT_VERSION -> a
com.badlogic.gdx.backends.android.surfaceview.GdxEglConfigChooser -> d.c:
    int[] mConfigAttribs -> h
    int[] mValue -> i
    int mStencilSize -> f
    int mNumSamples -> g
    int mAlphaSize -> d
    int mDepthSize -> e
    int mGreenSize -> b
    int mBlueSize -> c
    int mRedSize -> a
    javax.microedition.khronos.egl.EGLConfig chooseConfig(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig[]) -> a
    int findConfigAttrib(javax.microedition.khronos.egl.EGL10,javax.microedition.khronos.egl.EGLDisplay,javax.microedition.khronos.egl.EGLConfig,int,int) -> b
com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy -> d.d:
    com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy$MeasuredDimension calcMeasures(int,int) -> a
com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy$MeasuredDimension -> d.d$a:
    int height -> b
    int width -> a
com.badlogic.gdx.files.FileHandle -> e.a:
    java.io.File file -> a
    com.badlogic.gdx.Files$FileType type -> b
    com.badlogic.gdx.files.FileHandle child(java.lang.String) -> a
    int estimateLength() -> b
    boolean exists() -> c
    java.lang.String extension() -> d
    java.io.File file() -> e
    long length() -> f
    java.lang.String name() -> g
    java.lang.String nameWithoutExtension() -> h
    com.badlogic.gdx.files.FileHandle parent() -> i
    java.lang.String path() -> j
    java.io.InputStream read() -> k
    byte[] readBytes() -> l
    java.io.Reader reader(java.lang.String) -> m
    com.badlogic.gdx.files.FileHandle sibling(java.lang.String) -> n
    com.badlogic.gdx.Files$FileType type() -> o
com.badlogic.gdx.files.FileHandle$1 -> e.a$a:
    int[] $SwitchMap$com$badlogic$gdx$Files$FileType -> a
com.badlogic.gdx.graphics.Camera -> f.a:
    float viewportHeight -> k
    float viewportWidth -> j
    float far -> i
    float near -> h
    com.badlogic.gdx.math.Vector3 tmpVec -> m
    com.badlogic.gdx.math.Matrix4 projection -> d
    com.badlogic.gdx.math.Frustum frustum -> l
    com.badlogic.gdx.math.Vector3 direction -> b
    com.badlogic.gdx.math.Vector3 up -> c
    com.badlogic.gdx.math.Matrix4 invProjectionView -> g
    com.badlogic.gdx.math.Vector3 position -> a
    com.badlogic.gdx.math.Matrix4 view -> e
    com.badlogic.gdx.math.Matrix4 combined -> f
    com.badlogic.gdx.math.collision.Ray ray -> n
    com.badlogic.gdx.math.Vector3 project(com.badlogic.gdx.math.Vector3,float,float,float,float) -> a
    com.badlogic.gdx.math.Vector3 unproject(com.badlogic.gdx.math.Vector3,float,float,float,float) -> b
    void update() -> c
com.badlogic.gdx.graphics.Color -> f.b:
    com.badlogic.gdx.graphics.Color RED -> E
    com.badlogic.gdx.graphics.Color CORAL -> G
    com.badlogic.gdx.graphics.Color LIGHT_GRAY -> f
    com.badlogic.gdx.graphics.Color PINK -> I
    com.badlogic.gdx.graphics.Color DARK_GRAY -> h
    com.badlogic.gdx.graphics.Color PURPLE -> K
    float b -> c
    float r -> a
    com.badlogic.gdx.graphics.Color ORANGE -> A
    com.badlogic.gdx.graphics.Color TAN -> C
    com.badlogic.gdx.graphics.Color CHARTREUSE -> t
    com.badlogic.gdx.graphics.Color FOREST -> v
    com.badlogic.gdx.graphics.Color YELLOW -> x
    com.badlogic.gdx.graphics.Color GOLDENROD -> z
    com.badlogic.gdx.graphics.Color MAROON -> M
    com.badlogic.gdx.graphics.Color BLUE -> l
    com.badlogic.gdx.graphics.Color ROYAL -> n
    com.badlogic.gdx.graphics.Color SKY -> p
    com.badlogic.gdx.graphics.Color TEAL -> r
    com.badlogic.gdx.graphics.Color WHITE -> e
    com.badlogic.gdx.graphics.Color FIREBRICK -> D
    com.badlogic.gdx.graphics.Color GRAY -> g
    float WHITE_FLOAT_BITS -> j
    com.badlogic.gdx.graphics.Color SCARLET -> F
    com.badlogic.gdx.graphics.Color BLACK -> i
    com.badlogic.gdx.graphics.Color SALMON -> H
    com.badlogic.gdx.graphics.Color CLEAR -> k
    com.badlogic.gdx.graphics.Color MAGENTA -> J
    float a -> d
    float g -> b
    com.badlogic.gdx.graphics.Color BROWN -> B
    com.badlogic.gdx.graphics.Color LIME -> u
    com.badlogic.gdx.graphics.Color OLIVE -> w
    com.badlogic.gdx.graphics.Color GOLD -> y
    com.badlogic.gdx.graphics.Color NAVY -> m
    com.badlogic.gdx.graphics.Color VIOLET -> L
    com.badlogic.gdx.graphics.Color SLATE -> o
    com.badlogic.gdx.graphics.Color CYAN -> q
    com.badlogic.gdx.graphics.Color GREEN -> s
    void abgr8888ToColor(com.badlogic.gdx.graphics.Color,float) -> a
    void abgr8888ToColor(com.badlogic.gdx.graphics.Color,int) -> b
    com.badlogic.gdx.graphics.Color clamp() -> c
    com.badlogic.gdx.graphics.Color mul(com.badlogic.gdx.graphics.Color) -> d
    int rgba8888(float,float,float,float) -> e
    void rgba8888ToColor(com.badlogic.gdx.graphics.Color,int) -> f
    com.badlogic.gdx.graphics.Color set(float,float,float,float) -> g
    com.badlogic.gdx.graphics.Color set(com.badlogic.gdx.graphics.Color) -> h
    float toFloatBits() -> i
    float toFloatBits(float,float,float,float) -> j
    int toIntBits() -> k
    com.badlogic.gdx.graphics.Color valueOf(java.lang.String) -> l
    com.badlogic.gdx.graphics.Color valueOf(java.lang.String,com.badlogic.gdx.graphics.Color) -> m
com.badlogic.gdx.graphics.Colors -> f.c:
    com.badlogic.gdx.utils.ObjectMap map -> a
    com.badlogic.gdx.graphics.Color get(java.lang.String) -> a
    void reset() -> b
com.badlogic.gdx.graphics.Cubemap -> f.d:
    com.badlogic.gdx.graphics.CubemapData data -> i
    java.util.Map managedCubemaps -> j
    void clearAllCubemaps(com.badlogic.gdx.Application) -> Q
    java.lang.String getManagedStatus() -> R
    void invalidateAllCubemaps(com.badlogic.gdx.Application) -> S
    boolean isManaged() -> T
    void load(com.badlogic.gdx.graphics.CubemapData) -> U
    void reload() -> V
com.badlogic.gdx.graphics.CubemapData -> f.e:
    void prepare() -> a
    boolean isManaged() -> d
    boolean isPrepared() -> e
    void consumeCubemapData() -> g
com.badlogic.gdx.graphics.GL20 -> f.f:
    void glDrawElements(int,int,int,int) -> A
    int glGenFramebuffer() -> B
    java.lang.String glGetProgramInfoLog(int) -> C
    void glEnableVertexAttribArray(int) -> E
    java.lang.String glGetString(int) -> F
    void glClear(int) -> G
    void glUniform1i(int,int) -> H
    void glTexParameteri(int,int,int) -> I
    void glBindBuffer(int,int) -> J
    void glBufferData(int,int,java.nio.Buffer,int) -> L
    void glCompressedTexImage2D(int,int,int,int,int,int,int,java.nio.Buffer) -> M
    int glGetUniformLocation(int,java.lang.String) -> N
    void glDisable(int) -> O
    void glVertexAttribPointer(int,int,int,boolean,int,int) -> P
    int glGetAttribLocation(int,java.lang.String) -> Q
    void glPixelStorei(int,int) -> R
    java.lang.String glGetActiveAttrib(int,int,java.nio.IntBuffer,java.nio.IntBuffer) -> S
    void glDepthMask(boolean) -> T
    void glScissor(int,int,int,int) -> U
    void glDisableVertexAttribArray(int) -> V
    void glClearColor(float,float,float,float) -> W
    int glCreateShader(int) -> X
    void glDeleteTexture(int) -> Z
    void glEnable(int) -> a
    void glGetIntegerv(int,java.nio.IntBuffer) -> a0
    int glGenBuffer() -> b
    void glBindTexture(int,int) -> b0
    void glBindFramebuffer(int,int) -> c
    void glDeleteShader(int) -> c0
    void glDeleteProgram(int) -> d0
    void glCompileShader(int) -> e0
    void glDrawArrays(int,int,int) -> f
    void glDeleteBuffer(int) -> f0
    void glUniformMatrix4fv(int,int,boolean,float[],int) -> g
    void glGetShaderiv(int,int,java.nio.IntBuffer) -> g0
    void glVertexAttribPointer(int,int,int,boolean,int,java.nio.Buffer) -> h
    void glGetFloatv(int,java.nio.FloatBuffer) -> i
    void glViewport(int,int,int,int) -> j
    void glShaderSource(int,java.lang.String) -> k
    void glAttachShader(int,int) -> l
    void glTexParameterf(int,int,float) -> m
    java.lang.String glGetActiveUniform(int,int,java.nio.IntBuffer,java.nio.IntBuffer) -> n
    void glUseProgram(int) -> o
    void glGenerateMipmap(int) -> p
    void glGetProgramiv(int,int,java.nio.IntBuffer) -> q
    void glLinkProgram(int) -> r
    void glBufferSubData(int,int,int,java.nio.Buffer) -> s
    java.lang.String glGetShaderInfoLog(int) -> t
    void glDrawElements(int,int,int,java.nio.Buffer) -> v
    void glTexImage2D(int,int,int,int,int,int,int,int,java.nio.Buffer) -> w
    int glGenTexture() -> x
    int glCreateProgram() -> y
    void glBlendFuncSeparate(int,int,int,int) -> z
com.badlogic.gdx.graphics.GL30 -> f.g:
    void glDeleteVertexArrays(int,java.nio.IntBuffer) -> D
    void glGenVertexArrays(int,java.nio.IntBuffer) -> K
    void glBindVertexArray(int) -> Y
    void glDrawArraysInstanced(int,int,int,int) -> d
    void glTexImage3D(int,int,int,int,int,int,int,int,int,java.nio.Buffer) -> e
    void glDrawElementsInstanced(int,int,int,int,int) -> u
com.badlogic.gdx.graphics.GLTexture -> f.h:
    float maxAnisotropicFilterLevel -> h
    float anisotropicFilterLevel -> g
    int glHandle -> b
    com.badlogic.gdx.graphics.Texture$TextureWrap vWrap -> f
    com.badlogic.gdx.graphics.Texture$TextureWrap uWrap -> e
    com.badlogic.gdx.graphics.Texture$TextureFilter magFilter -> d
    int glTarget -> a
    com.badlogic.gdx.graphics.Texture$TextureFilter minFilter -> c
    void setFilter(com.badlogic.gdx.graphics.Texture$TextureFilter,com.badlogic.gdx.graphics.Texture$TextureFilter) -> A
    void bind() -> G
    void setWrap(com.badlogic.gdx.graphics.Texture$TextureWrap,com.badlogic.gdx.graphics.Texture$TextureWrap) -> H
    float unsafeSetAnisotropicFilter(float,boolean) -> K
    void unsafeSetFilter(com.badlogic.gdx.graphics.Texture$TextureFilter,com.badlogic.gdx.graphics.Texture$TextureFilter,boolean) -> M
    void unsafeSetWrap(com.badlogic.gdx.graphics.Texture$TextureWrap,com.badlogic.gdx.graphics.Texture$TextureWrap,boolean) -> N
    void uploadImageData(int,com.badlogic.gdx.graphics.TextureData) -> O
    void uploadImageData(int,com.badlogic.gdx.graphics.TextureData,int) -> P
    void delete() -> j
    com.badlogic.gdx.graphics.Texture$TextureFilter getMagFilter() -> n
    float getMaxAnisotropicFilterLevel() -> s
    com.badlogic.gdx.graphics.Texture$TextureFilter getMinFilter() -> u
com.badlogic.gdx.graphics.Mesh -> f.i:
    com.badlogic.gdx.graphics.glutils.VertexData vertices -> a
    com.badlogic.gdx.graphics.glutils.IndexData indices -> b
    com.badlogic.gdx.graphics.glutils.InstanceData instances -> e
    boolean isInstanced -> f
    boolean autoBind -> c
    boolean isVertexArray -> d
    com.badlogic.gdx.math.Vector3 tmpV -> g
    java.util.Map meshes -> h
    java.lang.String getManagedStatus() -> A
    com.badlogic.gdx.graphics.VertexAttribute getVertexAttribute(int) -> H
    com.badlogic.gdx.graphics.VertexAttributes getVertexAttributes() -> K
    int getNumIndices() -> L
    void invalidateAllMeshes(com.badlogic.gdx.Application) -> M
    com.badlogic.gdx.graphics.glutils.VertexData makeVertexBuffer(boolean,int,com.badlogic.gdx.graphics.VertexAttributes) -> N
    void render(com.badlogic.gdx.graphics.glutils.ShaderProgram,int) -> O
    void render(com.badlogic.gdx.graphics.glutils.ShaderProgram,int,int,int) -> P
    void render(com.badlogic.gdx.graphics.glutils.ShaderProgram,int,int,int,boolean) -> Q
    com.badlogic.gdx.graphics.Mesh setIndices(short[]) -> R
    com.badlogic.gdx.graphics.Mesh setVertices(float[],int,int) -> S
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram) -> T
    void dispose() -> a
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> e
    int getNumVertices() -> f
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> g
    void addManagedMesh(com.badlogic.gdx.Application,com.badlogic.gdx.graphics.Mesh) -> j
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram) -> n
    void clearAllMeshes(com.badlogic.gdx.Application) -> s
    java.nio.ShortBuffer getIndicesBuffer() -> u
com.badlogic.gdx.graphics.Mesh$1 -> f.i$a:
    int[] $SwitchMap$com$badlogic$gdx$graphics$Mesh$VertexDataType -> a
com.badlogic.gdx.graphics.Mesh$VertexDataType -> f.i$b:
    com.badlogic.gdx.graphics.Mesh$VertexDataType VertexBufferObject -> b
    com.badlogic.gdx.graphics.Mesh$VertexDataType VertexBufferObjectSubData -> c
    com.badlogic.gdx.graphics.Mesh$VertexDataType VertexArray -> a
    com.badlogic.gdx.graphics.Mesh$VertexDataType VertexBufferObjectWithVAO -> d
    com.badlogic.gdx.graphics.Mesh$VertexDataType[] $VALUES -> e
com.badlogic.gdx.graphics.OrthographicCamera -> f.j:
    com.badlogic.gdx.math.Vector3 tmp -> p
    float zoom -> o
    void update() -> c
    void setToOrtho(boolean,float,float) -> d
    void update(boolean) -> e
com.badlogic.gdx.graphics.Pixmap -> f.k:
    com.badlogic.gdx.graphics.g2d.Gdx2DPixmap pixmap -> c
    com.badlogic.gdx.graphics.Pixmap$Blending blending -> a
    boolean disposed -> e
    com.badlogic.gdx.graphics.Pixmap$Filter filter -> b
    int color -> d
    int getGLFormat() -> A
    int getGLInternalFormat() -> H
    void setColor(float,float,float,float) -> I
    int getGLType() -> K
    int getHeight() -> M
    java.nio.ByteBuffer getPixels() -> N
    int getWidth() -> O
    void setBlending(com.badlogic.gdx.graphics.Pixmap$Blending) -> P
    void dispose() -> a
    void drawPixmap(com.badlogic.gdx.graphics.Pixmap,int,int,int,int,int,int) -> j
    void drawPixmap(com.badlogic.gdx.graphics.Pixmap,int,int,int,int,int,int,int,int) -> n
    void fill() -> s
    com.badlogic.gdx.graphics.Pixmap$Format getFormat() -> u
com.badlogic.gdx.graphics.Pixmap$Blending -> f.k$a:
    com.badlogic.gdx.graphics.Pixmap$Blending[] $VALUES -> c
    com.badlogic.gdx.graphics.Pixmap$Blending None -> a
    com.badlogic.gdx.graphics.Pixmap$Blending SourceOver -> b
com.badlogic.gdx.graphics.Pixmap$Filter -> f.k$b:
    com.badlogic.gdx.graphics.Pixmap$Filter[] $VALUES -> c
    com.badlogic.gdx.graphics.Pixmap$Filter NearestNeighbour -> a
    com.badlogic.gdx.graphics.Pixmap$Filter BiLinear -> b
com.badlogic.gdx.graphics.Pixmap$Format -> f.k$c:
    com.badlogic.gdx.graphics.Pixmap$Format Alpha -> a
    com.badlogic.gdx.graphics.Pixmap$Format Intensity -> b
    com.badlogic.gdx.graphics.Pixmap$Format LuminanceAlpha -> c
    com.badlogic.gdx.graphics.Pixmap$Format RGB565 -> d
    com.badlogic.gdx.graphics.Pixmap$Format RGBA4444 -> e
    com.badlogic.gdx.graphics.Pixmap$Format RGB888 -> f
    com.badlogic.gdx.graphics.Pixmap$Format RGBA8888 -> g
    com.badlogic.gdx.graphics.Pixmap$Format[] $VALUES -> h
    com.badlogic.gdx.graphics.Pixmap$Format fromGdx2DPixmapFormat(int) -> a
    int toGdx2DPixmapFormat(com.badlogic.gdx.graphics.Pixmap$Format) -> b
com.badlogic.gdx.graphics.PixmapIO -> f.l:
    com.badlogic.gdx.graphics.Pixmap readCIM(com.badlogic.gdx.files.FileHandle) -> a
com.badlogic.gdx.graphics.PixmapIO$CIM -> f.l$a:
    byte[] readBuffer -> b
    byte[] writeBuffer -> a
    com.badlogic.gdx.graphics.Pixmap read(com.badlogic.gdx.files.FileHandle) -> a
com.badlogic.gdx.graphics.Texture -> f.m:
    java.util.Map managedTextures -> j
    com.badlogic.gdx.graphics.TextureData data -> i
    void addManagedTexture(com.badlogic.gdx.Application,com.badlogic.gdx.graphics.Texture) -> Q
    void clearAllTextures(com.badlogic.gdx.Application) -> R
    int getHeight() -> S
    java.lang.String getManagedStatus() -> T
    int getWidth() -> U
    void invalidateAllTextures(com.badlogic.gdx.Application) -> V
    boolean isManaged() -> W
    void load(com.badlogic.gdx.graphics.TextureData) -> X
    void reload() -> Y
    void dispose() -> a
com.badlogic.gdx.graphics.Texture$TextureFilter -> f.m$a:
    com.badlogic.gdx.graphics.Texture$TextureFilter Nearest -> b
    com.badlogic.gdx.graphics.Texture$TextureFilter MipMapLinearLinear -> h
    com.badlogic.gdx.graphics.Texture$TextureFilter MipMapNearestLinear -> g
    com.badlogic.gdx.graphics.Texture$TextureFilter MipMapLinearNearest -> f
    com.badlogic.gdx.graphics.Texture$TextureFilter MipMapNearestNearest -> e
    com.badlogic.gdx.graphics.Texture$TextureFilter MipMap -> d
    com.badlogic.gdx.graphics.Texture$TextureFilter[] $VALUES -> i
    int glEnum -> a
    com.badlogic.gdx.graphics.Texture$TextureFilter Linear -> c
    int getGLEnum() -> a
    boolean isMipMap() -> b
com.badlogic.gdx.graphics.Texture$TextureWrap -> f.m$b:
    com.badlogic.gdx.graphics.Texture$TextureWrap MirroredRepeat -> b
    com.badlogic.gdx.graphics.Texture$TextureWrap Repeat -> d
    com.badlogic.gdx.graphics.Texture$TextureWrap ClampToEdge -> c
    com.badlogic.gdx.graphics.Texture$TextureWrap[] $VALUES -> e
    int glEnum -> a
    int getGLEnum() -> a
com.badlogic.gdx.graphics.TextureArray -> f.n:
    com.badlogic.gdx.graphics.TextureArrayData data -> i
    java.util.Map managedTextureArrays -> j
    void clearAllTextureArrays(com.badlogic.gdx.Application) -> Q
    void invalidateAllTextureArrays(com.badlogic.gdx.Application) -> R
    boolean isManaged() -> S
    void load(com.badlogic.gdx.graphics.TextureArrayData) -> T
    void reload() -> U
com.badlogic.gdx.graphics.TextureArrayData -> f.o:
    void prepare() -> a
    int getWidth() -> b
    int getHeight() -> c
    boolean isManaged() -> d
    boolean isPrepared() -> e
    int getDepth() -> f
    int getInternalFormat() -> g
    void consumeTextureArrayData() -> h
    int getGLType() -> i
com.badlogic.gdx.graphics.TextureData -> f.p:
    void prepare() -> a
    int getWidth() -> b
    int getHeight() -> c
    boolean isManaged() -> d
    boolean isPrepared() -> e
    com.badlogic.gdx.graphics.TextureData$TextureDataType getType() -> f
    void consumeCustomData(int) -> h
    boolean disposePixmap() -> i
    com.badlogic.gdx.graphics.Pixmap consumePixmap() -> j
    com.badlogic.gdx.graphics.Pixmap$Format getFormat() -> k
    boolean useMipMaps() -> l
com.badlogic.gdx.graphics.TextureData$Factory -> f.p$a:
    com.badlogic.gdx.graphics.TextureData loadFromFile(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.graphics.Pixmap$Format,boolean) -> a
com.badlogic.gdx.graphics.TextureData$TextureDataType -> f.p$b:
    com.badlogic.gdx.graphics.TextureData$TextureDataType[] $VALUES -> c
    com.badlogic.gdx.graphics.TextureData$TextureDataType Pixmap -> a
    com.badlogic.gdx.graphics.TextureData$TextureDataType Custom -> b
com.badlogic.gdx.graphics.VertexAttribute -> f.q:
    java.lang.String alias -> f
    int usageIndex -> h
    int unit -> g
    int type -> d
    int offset -> e
    int numComponents -> b
    boolean normalized -> c
    int usage -> a
    boolean equals(com.badlogic.gdx.graphics.VertexAttribute) -> a
    int getKey() -> b
    int getSizeInBytes() -> c
com.badlogic.gdx.graphics.VertexAttributes -> f.r:
    com.badlogic.gdx.graphics.VertexAttributes$ReadonlyIterable iterable -> d
    long mask -> c
    int vertexSize -> b
    com.badlogic.gdx.graphics.VertexAttribute[] attributes -> a
    int calculateOffsets() -> a
    int compareTo(com.badlogic.gdx.graphics.VertexAttributes) -> b
    com.badlogic.gdx.graphics.VertexAttribute get(int) -> c
    long getMask() -> d
    int size() -> e
com.badlogic.gdx.graphics.VertexAttributes$ReadonlyIterable -> f.r$a:
    java.lang.Object[] array -> a
    com.badlogic.gdx.graphics.VertexAttributes$ReadonlyIterator iterator2 -> c
    com.badlogic.gdx.graphics.VertexAttributes$ReadonlyIterator iterator1 -> b
com.badlogic.gdx.graphics.VertexAttributes$ReadonlyIterator -> f.r$b:
    java.lang.Object[] array -> a
    int index -> b
    boolean valid -> c
com.badlogic.gdx.graphics.g2d.Batch -> g.a:
    void draw(com.badlogic.gdx.graphics.Texture,float,float,float,float,float,float,float,float) -> B
    void draw(com.badlogic.gdx.graphics.Texture,float[],int,int) -> C
    void begin() -> F
    void setColor(float,float,float,float) -> I
    void setProjectionMatrix(com.badlogic.gdx.math.Matrix4) -> J
    void end() -> d
    void setTransformMatrix(com.badlogic.gdx.math.Matrix4) -> i
    void setPackedColor(float) -> l
    void setColor(com.badlogic.gdx.graphics.Color) -> m
    float getPackedColor() -> p
    com.badlogic.gdx.graphics.Color getColor() -> q
    void draw(com.badlogic.gdx.graphics.g2d.TextureRegion,float,float,float,float,float,float,float,float,float) -> t
    void draw(com.badlogic.gdx.graphics.g2d.TextureRegion,float,float,float,float) -> w
    com.badlogic.gdx.math.Matrix4 getTransformMatrix() -> z
com.badlogic.gdx.graphics.g2d.BitmapFont -> g.b:
    com.badlogic.gdx.graphics.g2d.BitmapFontCache cache -> c
    com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData data -> a
    boolean integer -> e
    boolean ownsTexture -> f
    com.badlogic.gdx.utils.Array regions -> b
    boolean flipped -> d
    com.badlogic.gdx.utils.Array getRegions() -> A
    float getScaleX() -> H
    float getScaleY() -> K
    boolean isFlipped() -> M
    void load(com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData) -> N
    com.badlogic.gdx.graphics.g2d.BitmapFontCache newFontCache() -> O
    void dispose() -> a
    com.badlogic.gdx.graphics.g2d.GlyphLayout draw(com.badlogic.gdx.graphics.g2d.Batch,java.lang.CharSequence,float,float) -> j
    float getCapHeight() -> n
    com.badlogic.gdx.graphics.Color getColor() -> q
    com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData getData() -> s
    float getDescent() -> u
com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData -> g.b$a:
    float descent -> l
    float ascent -> k
    float capHeight -> j
    float lineHeight -> i
    com.badlogic.gdx.files.FileHandle fontFile -> c
    float padLeft -> h
    float padBottom -> g
    float padRight -> f
    float padTop -> e
    com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph[][] glyphs -> r
    boolean markupEnabled -> q
    java.lang.String[] imagePaths -> b
    char[] breakChars -> v
    char[] xChars -> w
    float xHeight -> u
    char[] capChars -> x
    com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph missingGlyph -> s
    float spaceXadvance -> t
    java.lang.String name -> a
    float scaleY -> p
    float scaleX -> o
    float blankLineScale -> n
    boolean flipped -> d
    float down -> m
    com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph getFirstGlyph() -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph getGlyph(char) -> b
    void getGlyphs(com.badlogic.gdx.graphics.g2d.GlyphLayout$GlyphRun,java.lang.CharSequence,int,int,com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph) -> c
    int getWrapIndex(com.badlogic.gdx.utils.Array,int) -> d
    boolean isBreakChar(char) -> e
    boolean isWhitespace(char) -> f
    void load(com.badlogic.gdx.files.FileHandle,boolean) -> g
    void setGlyph(int,com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph) -> h
    void setGlyphRegion(com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph,com.badlogic.gdx.graphics.g2d.TextureRegion) -> i
    void setScale(float) -> j
    void setScale(float,float) -> k
com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph -> g.b$b:
    boolean fixedWidth -> n
    int page -> o
    int xadvance -> l
    float v2 -> i
    float u2 -> h
    int xoffset -> j
    float v -> g
    int yoffset -> k
    float u -> f
    int width -> d
    int height -> e
    int srcX -> b
    int srcY -> c
    byte[][] kerning -> m
    int id -> a
    int getKerning(char) -> a
    void setKerning(int,int) -> b
com.badlogic.gdx.graphics.g2d.BitmapFontCache -> g.c:
    float currentTint -> i
    float y -> g
    com.badlogic.gdx.graphics.Color color -> h
    float x -> f
    com.badlogic.gdx.utils.IntArray[] pageGlyphIndices -> l
    int glyphCount -> e
    com.badlogic.gdx.utils.Array pooledLayouts -> d
    com.badlogic.gdx.utils.Array layouts -> c
    com.badlogic.gdx.graphics.Color tempColor -> n
    com.badlogic.gdx.graphics.g2d.BitmapFont font -> a
    float[][] pageVertices -> j
    boolean integer -> b
    int[] idx -> k
    int[] tempGlyphCount -> m
    void addGlyph(com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph,float,float,float) -> a
    com.badlogic.gdx.graphics.g2d.GlyphLayout addText(java.lang.CharSequence,float,float) -> b
    com.badlogic.gdx.graphics.g2d.GlyphLayout addText(java.lang.CharSequence,float,float,int,int,float,int,boolean,java.lang.String) -> c
    void addText(com.badlogic.gdx.graphics.g2d.GlyphLayout,float,float) -> d
    void addToCache(com.badlogic.gdx.graphics.g2d.GlyphLayout,float,float) -> e
    void clear() -> f
    void draw(com.badlogic.gdx.graphics.g2d.Batch) -> g
    com.badlogic.gdx.graphics.Color getColor() -> h
    com.badlogic.gdx.graphics.g2d.BitmapFont getFont() -> i
    void requireGlyphs(com.badlogic.gdx.graphics.g2d.GlyphLayout) -> j
    void requirePageGlyphs(int,int) -> k
    void setPageCount(int) -> l
    void setPosition(float,float) -> m
    void setText(com.badlogic.gdx.graphics.g2d.GlyphLayout,float,float) -> n
    void tint(com.badlogic.gdx.graphics.Color) -> o
    void translate(float,float) -> p
com.badlogic.gdx.graphics.g2d.Gdx2DPixmap -> com.badlogic.gdx.graphics.g2d.Gdx2DPixmap:
    long[] nativeData -> f
    long basePtr -> a
    java.nio.ByteBuffer pixelPtr -> e
    int format -> d
    int width -> b
    int height -> c
    int getFormat() -> A
    java.lang.String getFormatString(int) -> H
    int getGLFormat() -> K
    int getGLInternalFormat() -> M
    int getGLType() -> N
    int getHeight() -> O
    java.nio.ByteBuffer getPixels() -> P
    int getWidth() -> Q
    void setBlend(int) -> R
    int toGlFormat(int) -> S
    int toGlType(int) -> T
    void dispose() -> a
    void clear(int) -> j
    void convert(int) -> n
    void drawPixmap(com.badlogic.gdx.graphics.g2d.Gdx2DPixmap,int,int,int,int,int,int) -> s
    void drawPixmap(com.badlogic.gdx.graphics.g2d.Gdx2DPixmap,int,int,int,int,int,int,int,int) -> u
com.badlogic.gdx.graphics.g2d.GlyphLayout -> g.d:
    com.badlogic.gdx.utils.Array runs -> a
    com.badlogic.gdx.utils.IntArray colors -> b
    float height -> e
    float width -> d
    int glyphCount -> c
    com.badlogic.gdx.utils.Pool glyphRunPool -> f
    com.badlogic.gdx.utils.IntArray colorStack -> g
    void reset() -> a
    void alignRuns(float,int) -> b
    void calculateWidths(com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData) -> c
    float getGlyphWidth(com.badlogic.gdx.graphics.g2d.BitmapFont$Glyph,com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData) -> d
    float getLineOffset(com.badlogic.gdx.utils.Array,com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData) -> e
    int parseColorMarkup(java.lang.CharSequence,int,int) -> f
    void setLastGlyphXAdvance(com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData,com.badlogic.gdx.graphics.g2d.GlyphLayout$GlyphRun) -> g
    void setText(com.badlogic.gdx.graphics.g2d.BitmapFont,java.lang.CharSequence) -> h
    void setText(com.badlogic.gdx.graphics.g2d.BitmapFont,java.lang.CharSequence,int,int,com.badlogic.gdx.graphics.Color,float,int,boolean,java.lang.String) -> i
    void setText(com.badlogic.gdx.graphics.g2d.BitmapFont,java.lang.CharSequence,com.badlogic.gdx.graphics.Color,float,int,boolean) -> j
    void truncate(com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData,com.badlogic.gdx.graphics.g2d.GlyphLayout$GlyphRun,float,java.lang.String) -> k
    com.badlogic.gdx.graphics.g2d.GlyphLayout$GlyphRun wrap(com.badlogic.gdx.graphics.g2d.BitmapFont$BitmapFontData,com.badlogic.gdx.graphics.g2d.GlyphLayout$GlyphRun,int) -> l
com.badlogic.gdx.graphics.g2d.GlyphLayout$GlyphRun -> g.d$a:
    com.badlogic.gdx.utils.Array glyphs -> a
    float width -> e
    float y -> d
    float x -> c
    com.badlogic.gdx.utils.FloatArray xAdvances -> b
    void reset() -> a
    void appendRun(com.badlogic.gdx.graphics.g2d.GlyphLayout$GlyphRun) -> b
com.badlogic.gdx.graphics.g2d.NinePatch -> g.e:
    float rightWidth -> l
    float leftWidth -> k
    int topRight -> j
    int topLeft -> h
    int topCenter -> i
    int middleCenter -> f
    int middleRight -> g
    int bottomRight -> d
    int middleLeft -> e
    int bottomLeft -> b
    int bottomCenter -> c
    com.badlogic.gdx.graphics.Texture texture -> a
    float padBottom -> w
    com.badlogic.gdx.graphics.Color tmpDrawColor -> x
    float padTop -> v
    float padRight -> u
    float padLeft -> t
    float bottomHeight -> p
    float[] vertices -> q
    int idx -> r
    float topHeight -> o
    float middleHeight -> n
    com.badlogic.gdx.graphics.Color color -> s
    float middleWidth -> m
    int add(com.badlogic.gdx.graphics.g2d.TextureRegion,boolean,boolean) -> a
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> b
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float,float,float,float,float,float) -> c
    float getBottomHeight() -> d
    float getLeftWidth() -> e
    float getPadBottom() -> f
    float getPadLeft() -> g
    float getPadRight() -> h
    float getPadTop() -> i
    float getRightWidth() -> j
    float getTopHeight() -> k
    float getTotalHeight() -> l
    float getTotalWidth() -> m
    void load(com.badlogic.gdx.graphics.g2d.TextureRegion[]) -> n
    void prepareVertices(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> o
    void scale(float,float) -> p
    void set(int,float,float,float,float,float) -> q
    void setPadding(float,float,float,float) -> r
com.badlogic.gdx.graphics.g2d.Sprite -> g.f:
    float width -> l
    float y -> k
    float x -> j
    com.badlogic.gdx.graphics.Color color -> i
    float[] vertices -> h
    float scaleY -> r
    float scaleX -> q
    float rotation -> p
    float originY -> o
    float originX -> n
    boolean dirty -> s
    float height -> m
    void setColor(float,float,float,float) -> A
    void setColor(com.badlogic.gdx.graphics.Color) -> B
    void setOrigin(float,float) -> C
    void setPackedColor(float) -> D
    void setPosition(float,float) -> E
    void setRotation(float) -> F
    void setScale(float,float) -> G
    void setSize(float,float) -> H
    void setRegion(float,float,float,float) -> k
    void draw(com.badlogic.gdx.graphics.g2d.Batch) -> o
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> p
    com.badlogic.gdx.graphics.Color getColor() -> q
    float getHeight() -> r
    float[] getVertices() -> s
    float getWidth() -> t
    float getX() -> u
    float getY() -> v
    void rotate90(boolean) -> w
    void set(com.badlogic.gdx.graphics.g2d.Sprite) -> x
    void setAlpha(float) -> y
    void setBounds(float,float,float,float) -> z
com.badlogic.gdx.graphics.g2d.SpriteBatch -> g.g:
    int blendSrcFuncAlpha -> n
    int blendDstFuncAlpha -> o
    int blendSrcFunc -> l
    int blendDstFunc -> m
    float invTexHeight -> f
    boolean blendingDisabled -> k
    float invTexWidth -> e
    com.badlogic.gdx.graphics.glutils.ShaderProgram shader -> p
    com.badlogic.gdx.graphics.glutils.ShaderProgram customShader -> q
    com.badlogic.gdx.math.Matrix4 projectionMatrix -> i
    com.badlogic.gdx.math.Matrix4 combinedMatrix -> j
    float[] vertices -> b
    int idx -> c
    boolean ownsShader -> r
    com.badlogic.gdx.graphics.Mesh mesh -> a
    com.badlogic.gdx.graphics.Texture lastTexture -> d
    com.badlogic.gdx.math.Matrix4 transformMatrix -> h
    float colorPacked -> t
    int totalRenderCalls -> v
    int maxSpritesInBatch -> w
    boolean drawing -> g
    com.badlogic.gdx.graphics.Mesh$VertexDataType defaultVertexDataType -> x
    int renderCalls -> u
    com.badlogic.gdx.graphics.Color color -> s
    void draw(com.badlogic.gdx.graphics.Texture,float,float,float,float,float,float,float,float) -> B
    void draw(com.badlogic.gdx.graphics.Texture,float[],int,int) -> C
    void begin() -> F
    void setColor(float,float,float,float) -> I
    void setProjectionMatrix(com.badlogic.gdx.math.Matrix4) -> J
    void dispose() -> a
    void end() -> d
    void setTransformMatrix(com.badlogic.gdx.math.Matrix4) -> i
    com.badlogic.gdx.graphics.glutils.ShaderProgram createDefaultShader() -> j
    void setPackedColor(float) -> l
    void setColor(com.badlogic.gdx.graphics.Color) -> m
    boolean isBlendingEnabled() -> n
    float getPackedColor() -> p
    com.badlogic.gdx.graphics.Color getColor() -> q
    void setupMatrices() -> s
    void draw(com.badlogic.gdx.graphics.g2d.TextureRegion,float,float,float,float,float,float,float,float,float) -> t
    void switchTexture(com.badlogic.gdx.graphics.Texture) -> u
    void draw(com.badlogic.gdx.graphics.g2d.TextureRegion,float,float,float,float) -> w
    com.badlogic.gdx.math.Matrix4 getTransformMatrix() -> z
com.badlogic.gdx.graphics.g2d.TextureAtlas -> g.h:
    com.badlogic.gdx.utils.ObjectSet textures -> a
    com.badlogic.gdx.utils.Array regions -> b
    com.badlogic.gdx.utils.Array getRegions() -> j
    void load(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData) -> n
com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion -> g.h$a:
    int originalWidth -> n
    int[][] values -> s
    float offsetY -> k
    int originalHeight -> o
    java.lang.String name -> i
    float offsetX -> j
    int packedWidth -> l
    int packedHeight -> m
    boolean rotate -> p
    int index -> h
    int degrees -> q
    java.lang.String[] names -> r
    void flip(boolean,boolean) -> a
    int[] findValue(java.lang.String) -> o
    float getRotatedPackedHeight() -> p
    float getRotatedPackedWidth() -> q
com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasSprite -> g.h$b:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$AtlasRegion region -> t
    float originalOffsetY -> v
    float originalOffsetX -> u
    void setOrigin(float,float) -> C
    void setPosition(float,float) -> E
    void setSize(float,float) -> H
    float getHeight() -> r
    float getWidth() -> t
    float getX() -> u
    float getY() -> v
    void setBounds(float,float,float,float) -> z
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData -> g.h$c:
    com.badlogic.gdx.utils.Array pages -> a
    com.badlogic.gdx.utils.Array regions -> b
    void load(com.badlogic.gdx.files.FileHandle,com.badlogic.gdx.files.FileHandle,boolean) -> a
    int readEntry(java.lang.String[],java.lang.String) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$1 -> g.h$c$f:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData this$0 -> b
    java.lang.String[] val$entry -> a
    void parse(java.lang.Object) -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Page) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$10 -> g.h$c$a:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData this$0 -> b
    java.lang.String[] val$entry -> a
    void parse(java.lang.Object) -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$11 -> g.h$c$b:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData this$0 -> b
    java.lang.String[] val$entry -> a
    void parse(java.lang.Object) -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$12 -> g.h$c$c:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData this$0 -> b
    java.lang.String[] val$entry -> a
    void parse(java.lang.Object) -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$13 -> g.h$c$d:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData this$0 -> c
    boolean[] val$hasIndexes -> b
    java.lang.String[] val$entry -> a
    void parse(java.lang.Object) -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$14 -> g.h$c$e:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData this$0 -> a
    int compare(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region,com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region) -> a
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$2 -> g.h$c$g:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData this$0 -> b
    java.lang.String[] val$entry -> a
    void parse(java.lang.Object) -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Page) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$3 -> g.h$c$h:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData this$0 -> b
    java.lang.String[] val$entry -> a
    void parse(java.lang.Object) -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Page) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$4 -> g.h$c$i:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData this$0 -> b
    java.lang.String[] val$entry -> a
    void parse(java.lang.Object) -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Page) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$5 -> g.h$c$j:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData this$0 -> b
    java.lang.String[] val$entry -> a
    void parse(java.lang.Object) -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Page) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$6 -> g.h$c$k:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData this$0 -> b
    java.lang.String[] val$entry -> a
    void parse(java.lang.Object) -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$7 -> g.h$c$l:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData this$0 -> b
    java.lang.String[] val$entry -> a
    void parse(java.lang.Object) -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$8 -> g.h$c$m:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData this$0 -> b
    java.lang.String[] val$entry -> a
    void parse(java.lang.Object) -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$9 -> g.h$c$n:
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData this$0 -> b
    java.lang.String[] val$entry -> a
    void parse(java.lang.Object) -> a
    void parse(com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region) -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Field -> g.h$c$o:
    void parse(java.lang.Object) -> a
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Page -> g.h$c$p:
    com.badlogic.gdx.files.FileHandle textureFile -> a
    boolean pma -> k
    com.badlogic.gdx.graphics.Pixmap$Format format -> f
    float height -> d
    boolean useMipMaps -> e
    com.badlogic.gdx.graphics.Texture$TextureWrap vWrap -> j
    float width -> c
    com.badlogic.gdx.graphics.Texture$TextureWrap uWrap -> i
    com.badlogic.gdx.graphics.Texture$TextureFilter magFilter -> h
    com.badlogic.gdx.graphics.Texture$TextureFilter minFilter -> g
    com.badlogic.gdx.graphics.Texture texture -> b
com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Region -> g.h$c$q:
    int index -> m
    boolean flip -> p
    float offsetY -> h
    int originalHeight -> j
    float offsetX -> g
    int degrees -> k
    int originalWidth -> i
    boolean rotate -> l
    int height -> f
    int top -> d
    int width -> e
    int left -> c
    com.badlogic.gdx.graphics.g2d.TextureAtlas$TextureAtlasData$Page page -> a
    java.lang.String[] names -> n
    int[][] values -> o
    java.lang.String name -> b
com.badlogic.gdx.graphics.g2d.TextureRegion -> g.i:
    float v2 -> e
    float u2 -> d
    int regionWidth -> f
    float v -> c
    int regionHeight -> g
    float u -> b
    com.badlogic.gdx.graphics.Texture texture -> a
    void flip(boolean,boolean) -> a
    int getRegionHeight() -> b
    int getRegionWidth() -> c
    int getRegionX() -> d
    int getRegionY() -> e
    com.badlogic.gdx.graphics.Texture getTexture() -> f
    float getU() -> g
    float getU2() -> h
    float getV() -> i
    float getV2() -> j
    void setRegion(float,float,float,float) -> k
    void setRegion(int,int,int,int) -> l
    void setRegion(com.badlogic.gdx.graphics.g2d.TextureRegion) -> m
    void setRegion(com.badlogic.gdx.graphics.g2d.TextureRegion,int,int,int,int) -> n
com.badlogic.gdx.graphics.glutils.ETC1 -> com.badlogic.gdx.graphics.glutils.ETC1:
    int ETC1_RGB8_OES -> b
    int PKM_HEADER_SIZE -> a
    com.badlogic.gdx.graphics.Pixmap decodeImage(com.badlogic.gdx.graphics.glutils.ETC1$ETC1Data,com.badlogic.gdx.graphics.Pixmap$Format) -> a
    int getPixelSize(com.badlogic.gdx.graphics.Pixmap$Format) -> b
com.badlogic.gdx.graphics.glutils.ETC1$ETC1Data -> com.badlogic.gdx.graphics.glutils.ETC1$a:
    int dataOffset -> d
    java.nio.ByteBuffer compressedData -> c
    int height -> b
    int width -> a
    void dispose() -> a
    void checkNPOT() -> j
    boolean hasPKMHeader() -> n
com.badlogic.gdx.graphics.glutils.ETC1TextureData -> com.badlogic.gdx.graphics.glutils.a:
    com.badlogic.gdx.files.FileHandle file -> a
    boolean isPrepared -> f
    int width -> d
    com.badlogic.gdx.graphics.glutils.ETC1$ETC1Data data -> b
    int height -> e
    boolean useMipMaps -> c
    void prepare() -> a
    int getWidth() -> b
    int getHeight() -> c
    boolean isManaged() -> d
    boolean isPrepared() -> e
    com.badlogic.gdx.graphics.TextureData$TextureDataType getType() -> f
    void consumeCustomData(int) -> h
    boolean disposePixmap() -> i
    com.badlogic.gdx.graphics.Pixmap consumePixmap() -> j
    com.badlogic.gdx.graphics.Pixmap$Format getFormat() -> k
    boolean useMipMaps() -> l
com.badlogic.gdx.graphics.glutils.FileTextureData -> h.a:
    com.badlogic.gdx.graphics.Pixmap pixmap -> e
    com.badlogic.gdx.files.FileHandle file -> a
    com.badlogic.gdx.graphics.Pixmap$Format format -> d
    boolean useMipMaps -> f
    boolean isPrepared -> g
    int width -> b
    int height -> c
    void prepare() -> a
    int getWidth() -> b
    int getHeight() -> c
    boolean isManaged() -> d
    boolean isPrepared() -> e
    com.badlogic.gdx.graphics.TextureData$TextureDataType getType() -> f
    void consumeCustomData(int) -> h
    boolean disposePixmap() -> i
    com.badlogic.gdx.graphics.Pixmap consumePixmap() -> j
    com.badlogic.gdx.graphics.Pixmap$Format getFormat() -> k
    boolean useMipMaps() -> l
com.badlogic.gdx.graphics.glutils.GLFrameBuffer -> h.b:
    java.util.Map buffers -> c
    com.badlogic.gdx.utils.Array textureAttachments -> a
    boolean defaultFramebufferHandleInitialized -> e
    int defaultFramebufferHandle -> d
    int framebufferHandle -> b
    java.lang.StringBuilder getManagedStatus(java.lang.StringBuilder) -> A
    void invalidateAllFrameBuffers(com.badlogic.gdx.Application) -> H
    void build() -> j
    void checkValidBuilder() -> n
    void clearAllFrameBuffers(com.badlogic.gdx.Application) -> s
    java.lang.String getManagedStatus() -> u
com.badlogic.gdx.graphics.glutils.GLVersion -> h.c:
    java.lang.String TAG -> g
    int minorVersion -> b
    int releaseVersion -> c
    com.badlogic.gdx.graphics.glutils.GLVersion$Type type -> f
    java.lang.String rendererString -> e
    int majorVersion -> a
    java.lang.String vendorString -> d
    void extractVersion(java.lang.String,java.lang.String) -> a
    int getMajorVersion() -> b
    int parseInt(java.lang.String,int) -> c
com.badlogic.gdx.graphics.glutils.GLVersion$Type -> h.c$a:
    com.badlogic.gdx.graphics.glutils.GLVersion$Type WebGL -> c
    com.badlogic.gdx.graphics.glutils.GLVersion$Type GLES -> b
    com.badlogic.gdx.graphics.glutils.GLVersion$Type NONE -> d
    com.badlogic.gdx.graphics.glutils.GLVersion$Type OpenGL -> a
    com.badlogic.gdx.graphics.glutils.GLVersion$Type[] $VALUES -> e
com.badlogic.gdx.graphics.glutils.HdpiMode -> h.d:
    com.badlogic.gdx.graphics.glutils.HdpiMode Pixels -> b
    com.badlogic.gdx.graphics.glutils.HdpiMode Logical -> a
    com.badlogic.gdx.graphics.glutils.HdpiMode[] $VALUES -> c
com.badlogic.gdx.graphics.glutils.HdpiUtils -> h.e:
    com.badlogic.gdx.graphics.glutils.HdpiMode mode -> a
    void glScissor(int,int,int,int) -> a
    void glViewport(int,int,int,int) -> b
    int toBackBufferX(int) -> c
    int toBackBufferY(int) -> d
com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer -> h.g:
    void end() -> d
    int getNumVertices() -> f
    int getMaxVertices() -> g
    void color(float) -> h
    void vertex(float,float,float) -> i
    void begin(com.badlogic.gdx.math.Matrix4,int) -> j
    void color(float,float,float,float) -> k
com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer20 -> h.f:
    int colorOffset -> l
    com.badlogic.gdx.graphics.glutils.ShaderProgram shader -> g
    int texCoordOffset -> m
    int vertexSize -> j
    int normalOffset -> k
    int numTexCoords -> i
    int maxVertices -> d
    int numVertices -> e
    com.badlogic.gdx.graphics.Mesh mesh -> f
    int vertexIdx -> b
    int numSetTexCoords -> c
    int primitiveType -> a
    com.badlogic.gdx.math.Matrix4 projModelView -> n
    boolean ownsShader -> h
    java.lang.String[] shaderUniformNames -> p
    float[] vertices -> o
    com.badlogic.gdx.graphics.VertexAttribute[] buildVertexAttributes(boolean,boolean,int) -> a
    com.badlogic.gdx.graphics.glutils.ShaderProgram createDefaultShader(boolean,boolean,int) -> b
    java.lang.String createFragmentShader(boolean,boolean,int) -> c
    void end() -> d
    java.lang.String createVertexShader(boolean,boolean,int) -> e
    int getNumVertices() -> f
    int getMaxVertices() -> g
    void color(float) -> h
    void vertex(float,float,float) -> i
    void begin(com.badlogic.gdx.math.Matrix4,int) -> j
    void color(float,float,float,float) -> k
    void flush() -> l
com.badlogic.gdx.graphics.glutils.IndexArray -> h.h:
    java.nio.ShortBuffer buffer -> a
    java.nio.ByteBuffer byteBuffer -> b
    boolean empty -> c
    int getNumMaxIndices() -> D
    void bind() -> G
    int getNumIndices() -> L
    void dispose() -> a
    void invalidate() -> h
    java.nio.ShortBuffer getBuffer() -> k
    void unbind() -> r
    void setIndices(short[],int,int) -> v
com.badlogic.gdx.graphics.glutils.IndexBufferObject -> h.i:
    boolean empty -> i
    int usage -> h
    boolean isDirect -> e
    boolean isDirty -> f
    java.nio.ShortBuffer buffer -> a
    int bufferHandle -> d
    boolean isBound -> g
    java.nio.ByteBuffer byteBuffer -> b
    boolean ownsBuffer -> c
    int getNumMaxIndices() -> D
    void bind() -> G
    int getNumIndices() -> L
    void dispose() -> a
    void invalidate() -> h
    java.nio.ShortBuffer getBuffer() -> k
    void unbind() -> r
    void setIndices(short[],int,int) -> v
com.badlogic.gdx.graphics.glutils.IndexBufferObjectSubData -> h.j:
    boolean isDirty -> e
    boolean isBound -> f
    int usage -> g
    java.nio.ShortBuffer buffer -> a
    java.nio.ByteBuffer byteBuffer -> b
    int bufferHandle -> c
    boolean isDirect -> d
    int getNumMaxIndices() -> D
    void bind() -> G
    int getNumIndices() -> L
    void dispose() -> a
    void invalidate() -> h
    int createBufferObject() -> j
    java.nio.ShortBuffer getBuffer() -> k
    void unbind() -> r
    void setIndices(short[],int,int) -> v
com.badlogic.gdx.graphics.glutils.IndexData -> h.k:
    int getNumMaxIndices() -> D
    void bind() -> G
    int getNumIndices() -> L
    void dispose() -> a
    void invalidate() -> h
    java.nio.ShortBuffer getBuffer() -> k
    void unbind() -> r
    void setIndices(short[],int,int) -> v
com.badlogic.gdx.graphics.glutils.InstanceData -> h.l:
    void dispose() -> a
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> e
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> g
    int getNumInstances() -> o
com.badlogic.gdx.graphics.glutils.KTXTextureData -> com.badlogic.gdx.graphics.glutils.b:
    java.nio.ByteBuffer compressedData -> n
    com.badlogic.gdx.files.FileHandle file -> a
    int numberOfMipmapLevels -> l
    boolean useMipMaps -> o
    int imagePos -> m
    int numberOfArrayElements -> j
    int numberOfFaces -> k
    int pixelHeight -> h
    int pixelDepth -> i
    int glBaseInternalFormat -> f
    int pixelWidth -> g
    int glFormat -> d
    int glInternalFormat -> e
    int glType -> b
    int glTypeSize -> c
    void prepare() -> a
    int getWidth() -> b
    int getHeight() -> c
    boolean isManaged() -> d
    boolean isPrepared() -> e
    com.badlogic.gdx.graphics.TextureData$TextureDataType getType() -> f
    void consumeCubemapData() -> g
    void consumeCustomData(int) -> h
    boolean disposePixmap() -> i
    com.badlogic.gdx.graphics.Pixmap consumePixmap() -> j
    com.badlogic.gdx.graphics.Pixmap$Format getFormat() -> k
    boolean useMipMaps() -> l
    void disposePreparedData() -> m
com.badlogic.gdx.graphics.glutils.MipMapGenerator -> h.m:
    boolean useHWMipMap -> a
    void generateMipMap(int,com.badlogic.gdx.graphics.Pixmap,int,int) -> a
    void generateMipMapCPU(int,com.badlogic.gdx.graphics.Pixmap,int,int) -> b
    void generateMipMapDesktop(int,com.badlogic.gdx.graphics.Pixmap,int,int) -> c
    void generateMipMapGLES20(int,com.badlogic.gdx.graphics.Pixmap) -> d
com.badlogic.gdx.graphics.glutils.ShaderProgram -> h.n:
    com.badlogic.gdx.utils.ObjectIntMap attributeSizes -> i
    int vertexShaderHandle -> l
    com.badlogic.gdx.utils.ObjectIntMap attributes -> g
    com.badlogic.gdx.utils.ObjectIntMap uniformSizes -> e
    boolean pedantic -> u
    java.nio.IntBuffer type -> t
    java.lang.String fragmentShaderSource -> p
    boolean invalidated -> q
    java.lang.String prependVertexCode -> v
    java.lang.String[] attributeNames -> j
    com.badlogic.gdx.utils.ObjectIntMap uniformTypes -> d
    java.lang.String log -> a
    boolean isCompiled -> b
    int fragmentShaderHandle -> m
    com.badlogic.gdx.utils.ObjectIntMap attributeTypes -> h
    int program -> k
    java.lang.String vertexShaderSource -> o
    java.nio.IntBuffer params -> s
    java.lang.String[] uniformNames -> f
    java.nio.IntBuffer intbuf -> y
    java.lang.String prependFragmentCode -> w
    com.badlogic.gdx.utils.ObjectMap shaders -> x
    com.badlogic.gdx.utils.ObjectIntMap uniforms -> c
    java.nio.FloatBuffer matrix -> n
    int refCount -> r
    int createProgram() -> A
    void bind() -> G
    void disableVertexAttribute(int) -> H
    void disableVertexAttribute(java.lang.String) -> K
    void enableVertexAttribute(int) -> M
    int fetchAttributeLocation(java.lang.String) -> N
    void fetchAttributes() -> O
    int fetchUniformLocation(java.lang.String) -> P
    int fetchUniformLocation(java.lang.String,boolean) -> Q
    void fetchUniforms() -> R
    int getAttributeLocation(java.lang.String) -> S
    java.lang.String getLog() -> T
    java.lang.String getManagedStatus() -> U
    void invalidateAllShaderPrograms(com.badlogic.gdx.Application) -> V
    boolean isCompiled() -> W
    int linkProgram(int) -> X
    int loadShader(int,java.lang.String) -> Y
    void setUniformMatrix(int,com.badlogic.gdx.math.Matrix4,boolean) -> Z
    void dispose() -> a
    void setUniformMatrix(java.lang.String,com.badlogic.gdx.math.Matrix4) -> a0
    void setUniformMatrix(java.lang.String,com.badlogic.gdx.math.Matrix4,boolean) -> b0
    void setUniformi(java.lang.String,int) -> c0
    void setVertexAttribute(int,int,int,boolean,int,int) -> d0
    void setVertexAttribute(int,int,int,boolean,int,java.nio.Buffer) -> e0
    void addManagedShader(com.badlogic.gdx.Application,com.badlogic.gdx.graphics.glutils.ShaderProgram) -> j
    void checkManaged() -> n
    void clearAllShaderPrograms(com.badlogic.gdx.Application) -> s
    void compileShaders(java.lang.String,java.lang.String) -> u
com.badlogic.gdx.graphics.glutils.ShapeRenderer -> h.o:
    com.badlogic.gdx.math.Matrix4 projectionMatrix -> c
    com.badlogic.gdx.math.Matrix4 transformMatrix -> d
    com.badlogic.gdx.graphics.Color color -> g
    float defaultRectLineWidth -> j
    boolean autoShapeType -> i
    com.badlogic.gdx.math.Matrix4 combinedMatrix -> e
    com.badlogic.gdx.graphics.glutils.ImmediateModeRenderer renderer -> a
    boolean matrixDirty -> b
    com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType shapeType -> h
    com.badlogic.gdx.math.Vector2 tmp -> f
    void rect(float,float,float,float,float,float,float,float,float) -> A
    void begin() -> F
    void rect(float,float,float,float,float,float,float,float,float,com.badlogic.gdx.graphics.Color,com.badlogic.gdx.graphics.Color,com.badlogic.gdx.graphics.Color,com.badlogic.gdx.graphics.Color) -> H
    void setProjectionMatrix(com.badlogic.gdx.math.Matrix4) -> J
    void set(com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType) -> K
    void setAutoShapeType(boolean) -> M
    void end() -> d
    void setTransformMatrix(com.badlogic.gdx.math.Matrix4) -> i
    void begin(com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType) -> j
    void setColor(com.badlogic.gdx.graphics.Color) -> m
    void check(com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType,com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType,int) -> n
    boolean isDrawing() -> s
    void rect(float,float,float,float) -> u
    com.badlogic.gdx.math.Matrix4 getTransformMatrix() -> z
com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType -> h.o$a:
    com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType[] $VALUES -> e
    com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType Filled -> d
    com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType Line -> c
    com.badlogic.gdx.graphics.glutils.ShapeRenderer$ShapeType Point -> b
    int glType -> a
    int getGlType() -> a
com.badlogic.gdx.graphics.glutils.VertexArray -> h.p:
    java.nio.FloatBuffer buffer -> b
    java.nio.ByteBuffer byteBuffer -> c
    com.badlogic.gdx.graphics.VertexAttributes attributes -> a
    boolean isBound -> d
    void setVertices(float[],int,int) -> E
    void dispose() -> a
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> e
    int getNumVertices() -> f
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> g
    void invalidate() -> h
    com.badlogic.gdx.graphics.VertexAttributes getAttributes() -> x
com.badlogic.gdx.graphics.glutils.VertexBufferObject -> h.q:
    java.nio.FloatBuffer buffer -> b
    int usage -> f
    boolean isDirty -> g
    java.nio.ByteBuffer byteBuffer -> c
    int bufferHandle -> e
    boolean isBound -> h
    com.badlogic.gdx.graphics.VertexAttributes attributes -> a
    boolean ownsBuffer -> d
    void setVertices(float[],int,int) -> E
    void dispose() -> a
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> e
    int getNumVertices() -> f
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> g
    void invalidate() -> h
    void bufferChanged() -> j
    void setBuffer(java.nio.Buffer,boolean,com.badlogic.gdx.graphics.VertexAttributes) -> n
    void setUsage(int) -> s
    com.badlogic.gdx.graphics.VertexAttributes getAttributes() -> x
com.badlogic.gdx.graphics.glutils.VertexBufferObjectSubData -> h.r:
    java.nio.FloatBuffer buffer -> b
    boolean isBound -> i
    boolean isDirect -> e
    boolean isStatic -> f
    int usage -> g
    int bufferHandle -> d
    java.nio.ByteBuffer byteBuffer -> c
    boolean isDirty -> h
    com.badlogic.gdx.graphics.VertexAttributes attributes -> a
    void setVertices(float[],int,int) -> E
    void dispose() -> a
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> e
    int getNumVertices() -> f
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> g
    void invalidate() -> h
    void bufferChanged() -> j
    int createBufferObject() -> n
    com.badlogic.gdx.graphics.VertexAttributes getAttributes() -> x
com.badlogic.gdx.graphics.glutils.VertexBufferObjectWithVAO -> h.s:
    java.nio.FloatBuffer buffer -> b
    java.nio.IntBuffer tmpHandle -> l
    com.badlogic.gdx.utils.IntArray cachedLocations -> k
    boolean isBound -> i
    int vaoHandle -> j
    boolean isStatic -> f
    int usage -> g
    java.nio.ByteBuffer byteBuffer -> c
    int bufferHandle -> e
    boolean isDirty -> h
    com.badlogic.gdx.graphics.VertexAttributes attributes -> a
    boolean ownsBuffer -> d
    void deleteVAO() -> A
    void setVertices(float[],int,int) -> E
    void unbindAttributes(com.badlogic.gdx.graphics.glutils.ShaderProgram) -> H
    void dispose() -> a
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> e
    int getNumVertices() -> f
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> g
    void invalidate() -> h
    void bindAttributes(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> j
    void bindData(com.badlogic.gdx.graphics.GL20) -> n
    void bufferChanged() -> s
    void createVAO() -> u
    com.badlogic.gdx.graphics.VertexAttributes getAttributes() -> x
com.badlogic.gdx.graphics.glutils.VertexData -> h.t:
    void setVertices(float[],int,int) -> E
    void dispose() -> a
    void unbind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> e
    int getNumVertices() -> f
    void bind(com.badlogic.gdx.graphics.glutils.ShaderProgram,int[]) -> g
    void invalidate() -> h
    com.badlogic.gdx.graphics.VertexAttributes getAttributes() -> x
com.badlogic.gdx.math.Affine2 -> i.a:
    float m12 -> f
    float m11 -> e
    float m10 -> d
    float m02 -> c
    float m01 -> b
    float m00 -> a
    com.badlogic.gdx.math.Affine2 preMul(com.badlogic.gdx.math.Affine2) -> a
    com.badlogic.gdx.math.Affine2 setToTrnRotScl(float,float,float,float,float) -> b
    com.badlogic.gdx.math.Affine2 translate(float,float) -> c
com.badlogic.gdx.math.Frustum -> i.b:
    com.badlogic.gdx.math.Vector3[] planePoints -> b
    com.badlogic.gdx.math.Vector3[] clipSpacePlanePoints -> d
    float[] clipSpacePlanePointsArray -> e
    float[] planePointsArray -> c
    com.badlogic.gdx.math.Plane[] planes -> a
    com.badlogic.gdx.math.Vector3 tmpV -> f
    void update(com.badlogic.gdx.math.Matrix4) -> a
com.badlogic.gdx.math.Interpolation -> i.c:
com.badlogic.gdx.math.MathUtils -> i.d:
    java.util.Random random -> a
    float cosDeg(float) -> a
    boolean isEqual(float,float,float) -> b
    boolean isPowerOfTwo(int) -> c
    int nextPowerOfTwo(int) -> d
    int roundPositive(float) -> e
    float sinDeg(float) -> f
com.badlogic.gdx.math.MathUtils$Sin -> i.d$a:
    float[] table -> a
com.badlogic.gdx.math.Matrix4 -> com.badlogic.gdx.math.Matrix4:
    com.badlogic.gdx.math.Vector3 l_vez -> d
    com.badlogic.gdx.math.Vector3 l_vex -> e
    com.badlogic.gdx.math.Quaternion quat2 -> c
    com.badlogic.gdx.math.Quaternion quat -> b
    com.badlogic.gdx.math.Matrix4 tmpMat -> h
    com.badlogic.gdx.math.Vector3 tmpForward -> j
    com.badlogic.gdx.math.Vector3 tmpUp -> k
    float[] val -> a
    com.badlogic.gdx.math.Vector3 right -> i
    com.badlogic.gdx.math.Vector3 l_vey -> f
    com.badlogic.gdx.math.Vector3 tmpVec -> g
    float det(float[]) -> a
    com.badlogic.gdx.math.Matrix4 idt() -> b
    boolean inv(float[]) -> c
    com.badlogic.gdx.math.Matrix4 mul(com.badlogic.gdx.math.Matrix4) -> d
    void mul(float[],float[]) -> e
    com.badlogic.gdx.math.Matrix4 set(com.badlogic.gdx.math.Matrix4) -> f
    com.badlogic.gdx.math.Matrix4 set(com.badlogic.gdx.math.Affine2) -> g
    com.badlogic.gdx.math.Matrix4 set(float[]) -> h
    com.badlogic.gdx.math.Matrix4 setToLookAt(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3) -> i
    com.badlogic.gdx.math.Matrix4 setToLookAt(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3) -> j
    com.badlogic.gdx.math.Matrix4 setToOrtho(float,float,float,float,float,float) -> k
    com.badlogic.gdx.math.Matrix4 setToOrtho2D(float,float,float,float) -> l
    com.badlogic.gdx.math.Matrix4 setToTranslation(float,float,float) -> m
com.badlogic.gdx.math.Plane -> i.e:
    com.badlogic.gdx.math.Vector3 normal -> a
    float d -> b
    void set(com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3,com.badlogic.gdx.math.Vector3) -> a
com.badlogic.gdx.math.Quaternion -> i.f:
    com.badlogic.gdx.math.Quaternion tmp2 -> f
    com.badlogic.gdx.math.Quaternion tmp1 -> e
    float w -> d
    float z -> c
    float y -> b
    float x -> a
    com.badlogic.gdx.math.Quaternion idt() -> a
    com.badlogic.gdx.math.Quaternion set(float,float,float,float) -> b
com.badlogic.gdx.math.RandomXS128 -> i.g:
    long seed1 -> b
    long seed0 -> a
    long murmurHash3(long) -> a
    long nextLong(long) -> b
    void setState(long,long) -> c
com.badlogic.gdx.math.Rectangle -> i.h:
    com.badlogic.gdx.math.Rectangle tmp2 -> f
    com.badlogic.gdx.math.Rectangle tmp -> e
    float height -> d
    float width -> c
    float y -> b
    float x -> a
    float getX() -> a
    float getY() -> b
    com.badlogic.gdx.math.Rectangle set(float,float,float,float) -> c
    com.badlogic.gdx.math.Rectangle setPosition(float,float) -> d
    com.badlogic.gdx.math.Rectangle setWidth(float) -> e
com.badlogic.gdx.math.Vector2 -> i.i:
    com.badlogic.gdx.math.Vector2 X -> c
    com.badlogic.gdx.math.Vector2 Y -> d
    float y -> b
    float x -> a
    com.badlogic.gdx.math.Vector2 Zero -> e
    com.badlogic.gdx.math.Vector2 set(float,float) -> a
com.badlogic.gdx.math.Vector3 -> i.j:
    com.badlogic.gdx.math.Vector3 X -> d
    com.badlogic.gdx.math.Vector3 Y -> e
    com.badlogic.gdx.math.Matrix4 tmpMat -> h
    float z -> c
    float y -> b
    float x -> a
    com.badlogic.gdx.math.Vector3 Z -> f
    com.badlogic.gdx.math.Vector3 Zero -> g
    com.badlogic.gdx.math.Vector3 add(float,float,float) -> a
    com.badlogic.gdx.math.Vector3 add(com.badlogic.gdx.math.Vector3) -> b
    com.badlogic.gdx.math.Vector3 crs(float,float,float) -> c
    com.badlogic.gdx.math.Vector3 crs(com.badlogic.gdx.math.Vector3) -> d
    float dot(com.badlogic.gdx.math.Vector3) -> e
    float len2() -> f
    com.badlogic.gdx.math.Vector3 mul(com.badlogic.gdx.math.Matrix4) -> g
    com.badlogic.gdx.math.Vector3 nor() -> h
    com.badlogic.gdx.math.Vector3 prj(com.badlogic.gdx.math.Matrix4) -> i
    com.badlogic.gdx.math.Vector3 scl(float) -> j
    com.badlogic.gdx.math.Vector3 set(float,float,float) -> k
    com.badlogic.gdx.math.Vector3 set(com.badlogic.gdx.math.Vector3) -> l
    com.badlogic.gdx.math.Vector3 sub(float,float,float) -> m
    com.badlogic.gdx.math.Vector3 sub(com.badlogic.gdx.math.Vector3) -> n
com.badlogic.gdx.math.collision.Ray -> j.a:
    com.badlogic.gdx.math.Vector3 direction -> b
    com.badlogic.gdx.math.Vector3 tmp -> c
    com.badlogic.gdx.math.Vector3 origin -> a
com.badlogic.gdx.net.NetJavaImpl -> k.a:
    java.util.concurrent.ThreadPoolExecutor executorService -> a
    com.badlogic.gdx.utils.ObjectMap tasks -> d
    com.badlogic.gdx.utils.ObjectMap listeners -> c
    com.badlogic.gdx.utils.ObjectMap connections -> b
com.badlogic.gdx.net.NetJavaImpl$1 -> k.a$a:
    java.util.concurrent.atomic.AtomicInteger threadID -> a
    com.badlogic.gdx.net.NetJavaImpl this$0 -> b
com.badlogic.gdx.scenes.scene2d.Action -> l.a:
    com.badlogic.gdx.utils.Pool pool -> c
    com.badlogic.gdx.scenes.scene2d.Actor target -> b
    com.badlogic.gdx.scenes.scene2d.Actor actor -> a
    void reset() -> a
    boolean act(float) -> b
    com.badlogic.gdx.utils.Pool getPool() -> c
    void restart() -> d
    void setActor(com.badlogic.gdx.scenes.scene2d.Actor) -> e
    void setPool(com.badlogic.gdx.utils.Pool) -> f
    void setTarget(com.badlogic.gdx.scenes.scene2d.Actor) -> g
com.badlogic.gdx.scenes.scene2d.Actor -> l.b:
    float width -> l
    java.lang.String name -> f
    float y -> k
    float x -> j
    boolean debug -> i
    com.badlogic.gdx.scenes.scene2d.Touchable touchable -> g
    com.badlogic.gdx.scenes.scene2d.Group parent -> b
    com.badlogic.gdx.utils.DelayedRemovalArray listeners -> c
    com.badlogic.gdx.utils.DelayedRemovalArray captureListeners -> d
    com.badlogic.gdx.scenes.scene2d.Stage stage -> a
    com.badlogic.gdx.utils.Array actions -> e
    float rotation -> r
    boolean visible -> h
    float scaleY -> q
    float scaleX -> p
    float originY -> o
    float originX -> n
    com.badlogic.gdx.graphics.Color color -> s
    float height -> m
    float getScaleY() -> A
    com.badlogic.gdx.scenes.scene2d.Stage getStage() -> B
    com.badlogic.gdx.scenes.scene2d.Touchable getTouchable() -> C
    float getWidth() -> D
    float getX() -> E
    float getY() -> F
    boolean hasKeyboardFocus() -> G
    com.badlogic.gdx.scenes.scene2d.Actor hit(float,float,boolean) -> H
    boolean isDescendantOf(com.badlogic.gdx.scenes.scene2d.Actor) -> I
    boolean isVisible() -> J
    void moveBy(float,float) -> K
    boolean notify(com.badlogic.gdx.scenes.scene2d.Event,boolean) -> L
    com.badlogic.gdx.math.Vector2 parentToLocalCoordinates(com.badlogic.gdx.math.Vector2) -> M
    void positionChanged() -> N
    boolean remove() -> O
    void scaleChanged() -> P
    void setBounds(float,float,float,float) -> Q
    void setDebug(boolean) -> R
    void setHeight(float) -> S
    void setName(java.lang.String) -> T
    void setParent(com.badlogic.gdx.scenes.scene2d.Group) -> U
    void setPosition(float,float) -> V
    void setScale(float) -> W
    void setSize(float,float) -> X
    void setStage(com.badlogic.gdx.scenes.scene2d.Stage) -> Y
    void setTouchable(com.badlogic.gdx.scenes.scene2d.Touchable) -> Z
    void setWidth(float) -> a0
    void sizeChanged() -> b0
    com.badlogic.gdx.math.Vector2 stageToLocalCoordinates(com.badlogic.gdx.math.Vector2) -> c0
    void act(float) -> i
    void addAction(com.badlogic.gdx.scenes.scene2d.Action) -> j
    boolean addListener(com.badlogic.gdx.scenes.scene2d.EventListener) -> k
    boolean clipBegin(float,float,float,float) -> l
    void clipEnd() -> m
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> n
    void drawDebug(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> o
    void drawDebugBounds(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> p
    boolean fire(com.badlogic.gdx.scenes.scene2d.Event) -> q
    com.badlogic.gdx.graphics.Color getColor() -> r
    boolean getDebug() -> s
    float getHeight() -> t
    java.lang.String getName() -> u
    float getOriginX() -> v
    float getOriginY() -> w
    com.badlogic.gdx.scenes.scene2d.Group getParent() -> x
    float getRotation() -> y
    float getScaleX() -> z
com.badlogic.gdx.scenes.scene2d.Event -> l.c:
    com.badlogic.gdx.scenes.scene2d.Actor listenerActor -> c
    com.badlogic.gdx.scenes.scene2d.Actor targetActor -> b
    com.badlogic.gdx.scenes.scene2d.Stage stage -> a
    boolean bubbles -> e
    boolean handled -> f
    boolean stopped -> g
    boolean cancelled -> h
    boolean capture -> d
    void reset() -> a
    boolean getBubbles() -> b
    com.badlogic.gdx.scenes.scene2d.Actor getListenerActor() -> c
    com.badlogic.gdx.scenes.scene2d.Stage getStage() -> d
    com.badlogic.gdx.scenes.scene2d.Actor getTarget() -> e
    void handle() -> f
    boolean isCancelled() -> g
    boolean isHandled() -> h
    boolean isStopped() -> i
    void setCapture(boolean) -> j
    void setListenerActor(com.badlogic.gdx.scenes.scene2d.Actor) -> k
    void setStage(com.badlogic.gdx.scenes.scene2d.Stage) -> l
    void setTarget(com.badlogic.gdx.scenes.scene2d.Actor) -> m
com.badlogic.gdx.scenes.scene2d.EventListener -> l.d:
    boolean handle(com.badlogic.gdx.scenes.scene2d.Event) -> a
com.badlogic.gdx.scenes.scene2d.Group -> l.e:
    com.badlogic.gdx.utils.SnapshotArray children -> t
    com.badlogic.gdx.math.Matrix4 oldTransform -> w
    com.badlogic.gdx.math.Rectangle cullingArea -> y
    com.badlogic.gdx.math.Matrix4 computedTransform -> v
    com.badlogic.gdx.math.Affine2 worldTransform -> u
    boolean transform -> x
    com.badlogic.gdx.math.Vector2 tmp -> z
    com.badlogic.gdx.scenes.scene2d.Actor hit(float,float,boolean) -> H
    void setStage(com.badlogic.gdx.scenes.scene2d.Stage) -> Y
    void addActor(com.badlogic.gdx.scenes.scene2d.Actor) -> d0
    void applyTransform(com.badlogic.gdx.graphics.g2d.Batch,com.badlogic.gdx.math.Matrix4) -> e0
    void applyTransform(com.badlogic.gdx.graphics.glutils.ShapeRenderer,com.badlogic.gdx.math.Matrix4) -> f0
    void childrenChanged() -> g0
    com.badlogic.gdx.math.Matrix4 computeTransform() -> h0
    void act(float) -> i
    com.badlogic.gdx.scenes.scene2d.Group debugAll() -> i0
    void drawChildren(com.badlogic.gdx.graphics.g2d.Batch,float) -> j0
    void drawDebugChildren(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> k0
    com.badlogic.gdx.scenes.scene2d.Actor findActor(java.lang.String) -> l0
    com.badlogic.gdx.utils.SnapshotArray getChildren() -> m0
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> n
    boolean isTransform() -> n0
    void drawDebug(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> o
    boolean removeActor(com.badlogic.gdx.scenes.scene2d.Actor,boolean) -> o0
    com.badlogic.gdx.scenes.scene2d.Actor removeActorAt(int,boolean) -> p0
    void resetTransform(com.badlogic.gdx.graphics.g2d.Batch) -> q0
    void resetTransform(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> r0
    void setDebug(boolean,boolean) -> s0
    void setTransform(boolean) -> t0
    void toString(java.lang.StringBuilder,int) -> u0
com.badlogic.gdx.scenes.scene2d.InputEvent -> l.f:
    float scrollAmountX -> l
    int pointer -> n
    float stageY -> k
    int button -> o
    float stageX -> j
    com.badlogic.gdx.scenes.scene2d.Actor relatedActor -> r
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type type -> i
    char character -> q
    int keyCode -> p
    boolean touchFocus -> s
    float scrollAmountY -> m
    void setRelatedActor(com.badlogic.gdx.scenes.scene2d.Actor) -> A
    void setScrollAmountX(float) -> B
    void setScrollAmountY(float) -> C
    void setStageX(float) -> D
    void setStageY(float) -> E
    void setType(com.badlogic.gdx.scenes.scene2d.InputEvent$Type) -> F
    com.badlogic.gdx.math.Vector2 toCoordinates(com.badlogic.gdx.scenes.scene2d.Actor,com.badlogic.gdx.math.Vector2) -> G
    void reset() -> a
    int getButton() -> n
    char getCharacter() -> o
    int getKeyCode() -> p
    int getPointer() -> q
    com.badlogic.gdx.scenes.scene2d.Actor getRelatedActor() -> r
    float getScrollAmountX() -> s
    float getScrollAmountY() -> t
    boolean getTouchFocus() -> u
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type getType() -> v
    void setButton(int) -> w
    void setCharacter(char) -> x
    void setKeyCode(int) -> y
    void setPointer(int) -> z
com.badlogic.gdx.scenes.scene2d.InputEvent$Type -> l.f$a:
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type touchDown -> a
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type touchUp -> b
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type scrolled -> g
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type keyDown -> h
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type keyUp -> i
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type keyTyped -> j
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type touchDragged -> c
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type mouseMoved -> d
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type enter -> e
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type[] $VALUES -> k
    com.badlogic.gdx.scenes.scene2d.InputEvent$Type exit -> f
com.badlogic.gdx.scenes.scene2d.InputListener -> l.g:
    com.badlogic.gdx.math.Vector2 tmpCoords -> a
    boolean handle(com.badlogic.gdx.scenes.scene2d.Event) -> a
    void enter(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,com.badlogic.gdx.scenes.scene2d.Actor) -> b
    void exit(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,com.badlogic.gdx.scenes.scene2d.Actor) -> c
    boolean keyDown(com.badlogic.gdx.scenes.scene2d.InputEvent,int) -> d
    boolean keyTyped(com.badlogic.gdx.scenes.scene2d.InputEvent,char) -> e
    boolean keyUp(com.badlogic.gdx.scenes.scene2d.InputEvent,int) -> f
    boolean mouseMoved(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> g
    boolean scrolled(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,float,float) -> h
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> i
    void touchDragged(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> j
    void touchUp(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> k
com.badlogic.gdx.scenes.scene2d.InputListener$1 -> l.g$a:
    int[] $SwitchMap$com$badlogic$gdx$scenes$scene2d$InputEvent$Type -> a
com.badlogic.gdx.scenes.scene2d.Stage -> l.h:
    boolean actionsRequestRendering -> p
    int mouseScreenX -> j
    int mouseScreenY -> k
    com.badlogic.gdx.graphics.glutils.ShapeRenderer debugShapes -> q
    com.badlogic.gdx.graphics.g2d.Batch batch -> b
    boolean debug -> w
    boolean debugAll -> r
    com.badlogic.gdx.math.Vector2 tempCoords -> e
    boolean debugUnderMouse -> s
    boolean debugParentUnderMouse -> t
    com.badlogic.gdx.scenes.scene2d.Group root -> d
    com.badlogic.gdx.scenes.scene2d.Actor[] pointerOverActors -> f
    boolean[] pointerTouched -> g
    int[] pointerScreenX -> h
    int[] pointerScreenY -> i
    com.badlogic.gdx.graphics.Color debugColor -> v
    com.badlogic.gdx.utils.viewport.Viewport viewport -> a
    com.badlogic.gdx.utils.SnapshotArray touchFocuses -> o
    com.badlogic.gdx.scenes.scene2d.Actor keyboardFocus -> m
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug debugTableUnderMouse -> u
    com.badlogic.gdx.scenes.scene2d.Actor mouseOverActor -> l
    boolean ownsBatch -> c
    com.badlogic.gdx.scenes.scene2d.Actor scrollFocus -> n
    boolean touchDragged(int,int,int) -> A
    boolean mouseMoved(int,int) -> H
    boolean keyUp(int) -> K
    boolean touchUp(int,int,int,int) -> M
    void act(float) -> N
    void addActor(com.badlogic.gdx.scenes.scene2d.Actor) -> O
    void addTouchFocus(com.badlogic.gdx.scenes.scene2d.EventListener,com.badlogic.gdx.scenes.scene2d.Actor,com.badlogic.gdx.scenes.scene2d.Actor,int,int) -> P
    void calculateScissors(com.badlogic.gdx.math.Rectangle,com.badlogic.gdx.math.Rectangle) -> Q
    void cancelTouchFocus(com.badlogic.gdx.scenes.scene2d.Actor) -> R
    void disableDebug(com.badlogic.gdx.scenes.scene2d.Actor,com.badlogic.gdx.scenes.scene2d.Actor) -> S
    void draw() -> T
    void drawDebug() -> U
    com.badlogic.gdx.scenes.scene2d.Actor fireEnterAndExit(com.badlogic.gdx.scenes.scene2d.Actor,int,int,int) -> V
    boolean getActionsRequestRendering() -> W
    com.badlogic.gdx.utils.Array getActors() -> X
    com.badlogic.gdx.graphics.Color getDebugColor() -> Y
    float getHeight() -> Z
    com.badlogic.gdx.scenes.scene2d.Actor getKeyboardFocus() -> a0
    com.badlogic.gdx.scenes.scene2d.Group getRoot() -> b0
    com.badlogic.gdx.utils.viewport.Viewport getViewport() -> c0
    float getWidth() -> d0
    com.badlogic.gdx.scenes.scene2d.Actor hit(float,float,boolean) -> e0
    boolean isInsideViewport(int,int) -> f0
    com.badlogic.gdx.math.Vector2 screenToStageCoordinates(com.badlogic.gdx.math.Vector2) -> g0
    boolean setKeyboardFocus(com.badlogic.gdx.scenes.scene2d.Actor) -> h0
    boolean setScrollFocus(com.badlogic.gdx.scenes.scene2d.Actor) -> i0
    boolean scrolled(float,float) -> j
    void unfocus(com.badlogic.gdx.scenes.scene2d.Actor) -> j0
    boolean keyTyped(char) -> n
    boolean keyDown(int) -> s
    boolean touchDown(int,int,int,int) -> u
com.badlogic.gdx.scenes.scene2d.Stage$TouchFocus -> l.h$a:
    com.badlogic.gdx.scenes.scene2d.Actor target -> c
    com.badlogic.gdx.scenes.scene2d.Actor listenerActor -> b
    int pointer -> d
    int button -> e
    com.badlogic.gdx.scenes.scene2d.EventListener listener -> a
    void reset() -> a
com.badlogic.gdx.scenes.scene2d.Touchable -> l.i:
    com.badlogic.gdx.scenes.scene2d.Touchable[] $VALUES -> d
    com.badlogic.gdx.scenes.scene2d.Touchable disabled -> b
    com.badlogic.gdx.scenes.scene2d.Touchable childrenOnly -> c
    com.badlogic.gdx.scenes.scene2d.Touchable enabled -> a
com.badlogic.gdx.scenes.scene2d.actions.Actions -> m.a:
    com.badlogic.gdx.scenes.scene2d.Action action(java.lang.Class) -> a
    com.badlogic.gdx.scenes.scene2d.actions.AlphaAction alpha(float,float,com.badlogic.gdx.math.Interpolation) -> b
    com.badlogic.gdx.scenes.scene2d.actions.AlphaAction fadeIn(float) -> c
    com.badlogic.gdx.scenes.scene2d.actions.AlphaAction fadeOut(float) -> d
    com.badlogic.gdx.scenes.scene2d.actions.MoveByAction moveBy(float,float,float) -> e
    com.badlogic.gdx.scenes.scene2d.actions.MoveByAction moveBy(float,float,float,com.badlogic.gdx.math.Interpolation) -> f
    com.badlogic.gdx.scenes.scene2d.actions.SequenceAction sequence(com.badlogic.gdx.scenes.scene2d.Action) -> g
    com.badlogic.gdx.scenes.scene2d.actions.SequenceAction sequence(com.badlogic.gdx.scenes.scene2d.Action,com.badlogic.gdx.scenes.scene2d.Action) -> h
com.badlogic.gdx.scenes.scene2d.actions.AlphaAction -> m.b:
    float end -> j
    float start -> i
    com.badlogic.gdx.graphics.Color color -> k
    void reset() -> a
    void begin() -> h
    void update(float) -> l
    void setAlpha(float) -> m
com.badlogic.gdx.scenes.scene2d.actions.ColorAction -> m.c:
    float startA -> l
    float startB -> k
    float startG -> j
    float startR -> i
    com.badlogic.gdx.graphics.Color color -> m
    com.badlogic.gdx.graphics.Color end -> n
    void reset() -> a
    void begin() -> h
    void update(float) -> l
    void setEndColor(com.badlogic.gdx.graphics.Color) -> m
com.badlogic.gdx.scenes.scene2d.actions.MoveByAction -> m.d:
    float amountY -> k
    float amountX -> j
    void updateRelative(float) -> m
    void setAmount(float,float) -> n
com.badlogic.gdx.scenes.scene2d.actions.ParallelAction -> m.e:
    boolean complete -> e
    com.badlogic.gdx.utils.Array actions -> d
    void reset() -> a
    void restart() -> d
    void setActor(com.badlogic.gdx.scenes.scene2d.Actor) -> e
    void addAction(com.badlogic.gdx.scenes.scene2d.Action) -> h
com.badlogic.gdx.scenes.scene2d.actions.RelativeTemporalAction -> m.f:
    float lastPercent -> i
    void begin() -> h
    void update(float) -> l
    void updateRelative(float) -> m
com.badlogic.gdx.scenes.scene2d.actions.RunnableAction -> m.g:
    java.lang.Runnable runnable -> d
    boolean ran -> e
    void reset() -> a
    boolean act(float) -> b
    void restart() -> d
    void run() -> h
    void setRunnable(java.lang.Runnable) -> i
com.badlogic.gdx.scenes.scene2d.actions.SequenceAction -> m.h:
    int index -> f
    boolean act(float) -> b
    void restart() -> d
com.badlogic.gdx.scenes.scene2d.actions.TemporalAction -> m.i:
    float time -> e
    float duration -> d
    boolean reverse -> f
    boolean began -> g
    boolean complete -> h
    void reset() -> a
    boolean act(float) -> b
    void restart() -> d
    void begin() -> h
    void end() -> i
    void setDuration(float) -> j
    void setInterpolation(com.badlogic.gdx.math.Interpolation) -> k
    void update(float) -> l
com.badlogic.gdx.scenes.scene2d.ui.Button -> n.a:
    boolean isDisabled -> u0
    boolean isChecked -> t0
    boolean programmaticChangeEvents -> w0
    com.badlogic.gdx.scenes.scene2d.utils.ClickListener clickListener -> v0
    com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle style -> s0
    com.badlogic.gdx.scenes.scene2d.utils.Drawable getBackgroundDrawable() -> T0
    void initialize() -> U0
    boolean isChecked() -> V0
    boolean isDisabled() -> W0
    boolean isOver() -> X0
    boolean isPressed() -> Y0
    void setChecked(boolean,boolean) -> Z0
    float getMinHeight() -> a
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle) -> a1
    float getMinWidth() -> b
    float getPrefHeight() -> g
    float getPrefWidth() -> h
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> n
com.badlogic.gdx.scenes.scene2d.ui.Button$1 -> n.a$a:
    com.badlogic.gdx.scenes.scene2d.ui.Button this$0 -> p
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> l
com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle -> n.a$b:
    float unpressedOffsetX -> l
    float pressedOffsetY -> k
    float pressedOffsetX -> j
    com.badlogic.gdx.scenes.scene2d.utils.Drawable up -> a
    com.badlogic.gdx.scenes.scene2d.utils.Drawable down -> b
    com.badlogic.gdx.scenes.scene2d.utils.Drawable over -> c
    com.badlogic.gdx.scenes.scene2d.utils.Drawable focused -> d
    com.badlogic.gdx.scenes.scene2d.utils.Drawable disabled -> e
    com.badlogic.gdx.scenes.scene2d.utils.Drawable checked -> f
    com.badlogic.gdx.scenes.scene2d.utils.Drawable checkedOver -> g
    com.badlogic.gdx.scenes.scene2d.utils.Drawable checkedDown -> h
    com.badlogic.gdx.scenes.scene2d.utils.Drawable checkedFocused -> i
    float checkedOffsetY -> o
    float checkedOffsetX -> n
    float unpressedOffsetY -> m
com.badlogic.gdx.scenes.scene2d.ui.Cell -> n.b:
    com.badlogic.gdx.scenes.scene2d.ui.Value minWidth -> a
    com.badlogic.gdx.scenes.scene2d.ui.Value prefWidth -> c
    float computedPadRight -> J
    float computedPadLeft -> H
    int row -> E
    com.badlogic.gdx.Files files -> T
    java.lang.Integer righti -> S
    java.lang.Float fillY -> p
    java.lang.Integer colspan -> t
    java.lang.Boolean uniformY -> v
    float actorY -> y
    com.badlogic.gdx.scenes.scene2d.ui.Value padBottom -> m
    java.lang.Float zerof -> K
    com.badlogic.gdx.scenes.scene2d.ui.Value spaceBottom -> i
    com.badlogic.gdx.scenes.scene2d.ui.Table table -> B
    com.badlogic.gdx.scenes.scene2d.ui.Value padTop -> k
    java.lang.Integer zeroi -> M
    com.badlogic.gdx.scenes.scene2d.ui.Value maxWidth -> e
    java.lang.Integer centeri -> O
    com.badlogic.gdx.scenes.scene2d.ui.Cell defaults -> U
    com.badlogic.gdx.scenes.scene2d.ui.Value spaceTop -> g
    boolean endRow -> C
    java.lang.Integer bottomi -> Q
    java.lang.Integer expandX -> r
    com.badlogic.gdx.scenes.scene2d.ui.Value minHeight -> b
    float computedPadBottom -> I
    float computedPadTop -> G
    int cellAboveIndex -> F
    int column -> D
    float actorHeight -> A
    java.lang.Float fillX -> o
    java.lang.Integer expandY -> s
    java.lang.Boolean uniformX -> u
    float actorWidth -> z
    float actorX -> x
    com.badlogic.gdx.scenes.scene2d.ui.Value padLeft -> l
    java.lang.Float onef -> L
    com.badlogic.gdx.scenes.scene2d.Actor actor -> w
    com.badlogic.gdx.scenes.scene2d.ui.Value padRight -> n
    com.badlogic.gdx.scenes.scene2d.ui.Value spaceLeft -> h
    com.badlogic.gdx.scenes.scene2d.ui.Value spaceRight -> j
    java.lang.Integer onei -> N
    com.badlogic.gdx.scenes.scene2d.ui.Value prefHeight -> d
    java.lang.Integer topi -> P
    java.lang.Integer align -> q
    com.badlogic.gdx.scenes.scene2d.ui.Value maxHeight -> f
    java.lang.Integer lefti -> R
    void reset() -> a
    com.badlogic.gdx.scenes.scene2d.ui.Cell defaults() -> b
    com.badlogic.gdx.scenes.scene2d.ui.Cell expand() -> c
    com.badlogic.gdx.scenes.scene2d.ui.Cell fill() -> d
    void merge(com.badlogic.gdx.scenes.scene2d.ui.Cell) -> e
    void set(com.badlogic.gdx.scenes.scene2d.ui.Cell) -> f
    void setTable(com.badlogic.gdx.scenes.scene2d.ui.Table) -> g
com.badlogic.gdx.scenes.scene2d.ui.CheckBox$CheckBoxStyle -> n.c:
com.badlogic.gdx.scenes.scene2d.ui.Image -> n.d:
    com.badlogic.gdx.utils.Scaling scaling -> w
    float imageY -> z
    float imageX -> y
    int align -> x
    float imageHeight -> B
    float imageWidth -> A
    com.badlogic.gdx.scenes.scene2d.utils.Drawable drawable -> C
    float getMinHeight() -> a
    float getMinWidth() -> b
    void layout() -> e0
    void setDrawable(com.badlogic.gdx.scenes.scene2d.utils.Drawable) -> f0
    float getPrefHeight() -> g
    float getPrefWidth() -> h
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> n
com.badlogic.gdx.scenes.scene2d.ui.ImageButton$ImageButtonStyle -> n.e:
com.badlogic.gdx.scenes.scene2d.ui.ImageTextButton$ImageTextButtonStyle -> n.f:
com.badlogic.gdx.scenes.scene2d.ui.Label -> n.g:
    float fontScaleY -> J
    float fontScaleX -> I
    float lastPrefHeight -> G
    boolean fontScaleChanged -> K
    java.lang.String ellipsis -> L
    com.badlogic.gdx.scenes.scene2d.ui.Label$LabelStyle style -> w
    int labelAlign -> D
    int lineAlign -> E
    int intValue -> B
    float prefHeight -> z
    com.badlogic.gdx.graphics.g2d.GlyphLayout layout -> x
    float prefWidth -> y
    com.badlogic.gdx.graphics.g2d.BitmapFontCache cache -> C
    com.badlogic.gdx.utils.StringBuilder text -> A
    com.badlogic.gdx.graphics.Color tempColor -> M
    boolean wrap -> F
    com.badlogic.gdx.graphics.g2d.GlyphLayout prefSizeLayout -> N
    boolean prefSizeInvalid -> H
    void invalidate() -> d0
    void layout() -> e0
    void computePrefSize(com.badlogic.gdx.graphics.g2d.GlyphLayout) -> f0
    float getPrefHeight() -> g
    com.badlogic.gdx.scenes.scene2d.ui.Label$LabelStyle getStyle() -> g0
    float getPrefWidth() -> h
    com.badlogic.gdx.utils.StringBuilder getText() -> h0
    void scaleAndComputePrefSize() -> i0
    void setAlignment(int) -> j0
    void setAlignment(int,int) -> k0
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.Label$LabelStyle) -> l0
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> n
com.badlogic.gdx.scenes.scene2d.ui.Label$LabelStyle -> n.g$a:
    com.badlogic.gdx.scenes.scene2d.utils.Drawable background -> c
    com.badlogic.gdx.graphics.g2d.BitmapFont font -> a
    com.badlogic.gdx.graphics.Color fontColor -> b
com.badlogic.gdx.scenes.scene2d.ui.List$ListStyle -> n.h:
    com.badlogic.gdx.graphics.Color fontColorSelected -> a
    com.badlogic.gdx.graphics.Color fontColorUnselected -> b
com.badlogic.gdx.scenes.scene2d.ui.ProgressBar$ProgressBarStyle -> n.i:
com.badlogic.gdx.scenes.scene2d.ui.ScrollPane$ScrollPaneStyle -> n.j:
com.badlogic.gdx.scenes.scene2d.ui.SelectBox$SelectBoxStyle -> n.k:
    com.badlogic.gdx.graphics.Color fontColor -> a
com.badlogic.gdx.scenes.scene2d.ui.Skin -> n.l:
    java.lang.Class[] defaultTagClasses -> e
    com.badlogic.gdx.utils.ObjectMap resources -> a
    com.badlogic.gdx.graphics.g2d.TextureAtlas atlas -> b
    float scale -> c
    com.badlogic.gdx.utils.ObjectMap jsonClassTags -> d
    com.badlogic.gdx.scenes.scene2d.utils.Drawable getDrawable(java.lang.String) -> A
    com.badlogic.gdx.utils.Json getJsonLoader(com.badlogic.gdx.files.FileHandle) -> H
    com.badlogic.gdx.graphics.g2d.NinePatch getPatch(java.lang.String) -> K
    com.badlogic.gdx.graphics.g2d.TextureRegion getRegion(java.lang.String) -> M
    com.badlogic.gdx.utils.Array getRegions(java.lang.String) -> N
    com.badlogic.gdx.graphics.g2d.Sprite getSprite(java.lang.String) -> O
    void load(com.badlogic.gdx.files.FileHandle) -> P
    com.badlogic.gdx.scenes.scene2d.utils.Drawable newDrawable(java.lang.String,com.badlogic.gdx.graphics.Color) -> Q
    com.badlogic.gdx.scenes.scene2d.utils.Drawable newDrawable(com.badlogic.gdx.scenes.scene2d.utils.Drawable,com.badlogic.gdx.graphics.Color) -> R
    java.lang.Object optional(java.lang.String,java.lang.Class) -> S
    void scale(com.badlogic.gdx.scenes.scene2d.utils.Drawable) -> T
    void add(java.lang.String,java.lang.Object,java.lang.Class) -> j
    void addRegions(com.badlogic.gdx.graphics.g2d.TextureAtlas) -> n
    java.lang.Object get(java.lang.Class) -> s
    java.lang.Object get(java.lang.String,java.lang.Class) -> u
com.badlogic.gdx.scenes.scene2d.ui.Skin$1 -> n.l$a:
    com.badlogic.gdx.scenes.scene2d.ui.Skin this$0 -> q
    boolean ignoreUnknownField(java.lang.Class,java.lang.String) -> g
    void readFields(java.lang.Object,com.badlogic.gdx.utils.JsonValue) -> i
    java.lang.Object readValue(java.lang.Class,java.lang.Class,com.badlogic.gdx.utils.JsonValue) -> j
com.badlogic.gdx.scenes.scene2d.ui.Skin$2 -> n.l$b:
    com.badlogic.gdx.scenes.scene2d.ui.Skin val$skin -> a
    com.badlogic.gdx.scenes.scene2d.ui.Skin this$0 -> b
    java.lang.Object read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Skin read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> b
    void readNamedObjects(com.badlogic.gdx.utils.Json,java.lang.Class,com.badlogic.gdx.utils.JsonValue) -> c
com.badlogic.gdx.scenes.scene2d.ui.Skin$3 -> n.l$c:
    com.badlogic.gdx.files.FileHandle val$skinFile -> a
    com.badlogic.gdx.scenes.scene2d.ui.Skin this$0 -> c
    com.badlogic.gdx.scenes.scene2d.ui.Skin val$skin -> b
    java.lang.Object read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> a
    com.badlogic.gdx.graphics.g2d.BitmapFont read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> b
com.badlogic.gdx.scenes.scene2d.ui.Skin$4 -> n.l$d:
    com.badlogic.gdx.scenes.scene2d.ui.Skin this$0 -> a
    java.lang.Object read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> a
    com.badlogic.gdx.graphics.Color read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> b
com.badlogic.gdx.scenes.scene2d.ui.Skin$5 -> n.l$e:
    com.badlogic.gdx.scenes.scene2d.ui.Skin this$0 -> a
    java.lang.Object read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> a
com.badlogic.gdx.scenes.scene2d.ui.Skin$TintedDrawable -> n.l$f:
com.badlogic.gdx.scenes.scene2d.ui.Slider$SliderStyle -> n.m:
com.badlogic.gdx.scenes.scene2d.ui.SplitPane$SplitPaneStyle -> n.n:
com.badlogic.gdx.scenes.scene2d.ui.Table -> n.o:
    float[] rowMinHeight -> M
    com.badlogic.gdx.scenes.scene2d.ui.Value backgroundLeft -> p0
    com.badlogic.gdx.scenes.scene2d.ui.Value backgroundTop -> o0
    com.badlogic.gdx.scenes.scene2d.ui.Value backgroundRight -> r0
    boolean clip -> f0
    com.badlogic.gdx.scenes.scene2d.ui.Value backgroundBottom -> q0
    com.badlogic.gdx.scenes.scene2d.ui.Value padLeft -> Y
    int rows -> E
    com.badlogic.gdx.scenes.scene2d.ui.Skin skin -> g0
    float[] expandHeight -> W
    com.badlogic.gdx.scenes.scene2d.ui.Value padRight -> a0
    float[] rowHeight -> U
    float tablePrefWidth -> R
    com.badlogic.gdx.utils.Array columnDefaults -> I
    float tableMinWidth -> P
    com.badlogic.gdx.utils.Array cells -> G
    float[] rowPrefHeight -> O
    com.badlogic.gdx.scenes.scene2d.ui.Cell rowDefaults -> J
    float[] columnPrefWidth -> N
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug debug -> c0
    int align -> b0
    float[] columnMinWidth -> L
    com.badlogic.gdx.utils.Pool cellPool -> l0
    boolean sizeInvalid -> K
    com.badlogic.gdx.scenes.scene2d.ui.Value padTop -> X
    float[] columnWeightedWidth -> m0
    int columns -> D
    com.badlogic.gdx.scenes.scene2d.ui.Value padBottom -> Z
    com.badlogic.gdx.scenes.scene2d.utils.Drawable background -> e0
    com.badlogic.gdx.graphics.Color debugTableColor -> i0
    com.badlogic.gdx.graphics.Color debugCellColor -> j0
    com.badlogic.gdx.graphics.Color debugActorColor -> k0
    float[] rowWeightedHeight -> n0
    com.badlogic.gdx.scenes.scene2d.ui.Cell cellDefaults -> H
    com.badlogic.gdx.utils.Array debugRects -> d0
    boolean implicitEndRow -> F
    float tablePrefHeight -> S
    float[] expandWidth -> V
    float tableMinHeight -> Q
    float[] columnWidth -> T
    boolean round -> h0
    com.badlogic.gdx.scenes.scene2d.ui.Table align(int) -> A0
    void clearDebugRects() -> B0
    void computeSize() -> C0
    com.badlogic.gdx.scenes.scene2d.ui.Table debug(com.badlogic.gdx.scenes.scene2d.ui.Table$Debug) -> D0
    com.badlogic.gdx.scenes.scene2d.ui.Table debugAll() -> E0
    void drawBackground(com.badlogic.gdx.graphics.g2d.Batch,float,float,float) -> F0
    void drawDebugRects(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> G0
    com.badlogic.gdx.scenes.scene2d.Actor hit(float,float,boolean) -> H
    void endRow() -> H0
    float[] ensureSize(float[],int) -> I0
    com.badlogic.gdx.scenes.scene2d.ui.Cell getCell(com.badlogic.gdx.scenes.scene2d.Actor) -> J0
    float getPadBottom() -> K0
    float getPadLeft() -> L0
    float getPadRight() -> M0
    float getPadTop() -> N0
    com.badlogic.gdx.scenes.scene2d.ui.Cell obtainCell() -> O0
    com.badlogic.gdx.scenes.scene2d.ui.Table padRight(float) -> P0
    com.badlogic.gdx.scenes.scene2d.ui.Table padTop(float) -> Q0
    void setDebug(boolean) -> R
    void setBackground(com.badlogic.gdx.scenes.scene2d.utils.Drawable) -> R0
    void setSkin(com.badlogic.gdx.scenes.scene2d.ui.Skin) -> S0
    float getMinHeight() -> a
    float getMinWidth() -> b
    float getPrefHeight() -> g
    float getPrefWidth() -> h
    com.badlogic.gdx.scenes.scene2d.Group debugAll() -> i0
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> n
    void drawDebug(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> o
    boolean removeActor(com.badlogic.gdx.scenes.scene2d.Actor,boolean) -> o0
    void drawDebugBounds(com.badlogic.gdx.graphics.glutils.ShapeRenderer) -> p
    com.badlogic.gdx.scenes.scene2d.Actor removeActorAt(int,boolean) -> p0
    void invalidate() -> v0
    void layout() -> w0
    com.badlogic.gdx.scenes.scene2d.ui.Cell add(com.badlogic.gdx.scenes.scene2d.Actor) -> x0
    void addDebugRect(float,float,float,float,com.badlogic.gdx.graphics.Color) -> y0
    void addDebugRects(float,float,float,float) -> z0
com.badlogic.gdx.scenes.scene2d.ui.Table$1 -> n.o$a:
    java.lang.Object newObject() -> d
    com.badlogic.gdx.scenes.scene2d.ui.Cell newObject() -> g
com.badlogic.gdx.scenes.scene2d.ui.Table$2 -> n.o$b:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Table$3 -> n.o$c:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Table$4 -> n.o$d:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Table$5 -> n.o$e:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Table$Debug -> n.o$f:
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug[] $VALUES -> f
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug actor -> e
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug cell -> d
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug none -> a
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug table -> c
    com.badlogic.gdx.scenes.scene2d.ui.Table$Debug all -> b
com.badlogic.gdx.scenes.scene2d.ui.Table$DebugRect -> n.o$g:
    com.badlogic.gdx.graphics.Color color -> g
    com.badlogic.gdx.utils.Pool pool -> h
com.badlogic.gdx.scenes.scene2d.ui.TextButton -> n.p:
    com.badlogic.gdx.scenes.scene2d.ui.Label label -> x0
    com.badlogic.gdx.scenes.scene2d.ui.TextButton$TextButtonStyle style -> y0
    void setStyle(com.badlogic.gdx.scenes.scene2d.ui.Button$ButtonStyle) -> a1
    com.badlogic.gdx.graphics.Color getFontColor() -> b1
    com.badlogic.gdx.scenes.scene2d.ui.Label newLabel(java.lang.String,com.badlogic.gdx.scenes.scene2d.ui.Label$LabelStyle) -> c1
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> n
com.badlogic.gdx.scenes.scene2d.ui.TextButton$TextButtonStyle -> n.p$a:
    com.badlogic.gdx.graphics.Color disabledFontColor -> u
    com.badlogic.gdx.graphics.Color focusedFontColor -> t
    com.badlogic.gdx.graphics.Color checkedDownFontColor -> w
    com.badlogic.gdx.graphics.Color checkedFontColor -> v
    com.badlogic.gdx.graphics.Color checkedFocusedFontColor -> y
    com.badlogic.gdx.graphics.Color checkedOverFontColor -> x
    com.badlogic.gdx.graphics.Color fontColor -> q
    com.badlogic.gdx.graphics.g2d.BitmapFont font -> p
    com.badlogic.gdx.graphics.Color overFontColor -> s
    com.badlogic.gdx.graphics.Color downFontColor -> r
com.badlogic.gdx.scenes.scene2d.ui.TextField$TextFieldStyle -> n.q:
com.badlogic.gdx.scenes.scene2d.ui.TextTooltip$TextTooltipStyle -> n.r:
com.badlogic.gdx.scenes.scene2d.ui.Touchpad$TouchpadStyle -> n.s:
com.badlogic.gdx.scenes.scene2d.ui.Tree$TreeStyle -> n.t:
com.badlogic.gdx.scenes.scene2d.ui.Value -> n.u:
    com.badlogic.gdx.scenes.scene2d.ui.Value$Fixed zero -> a
    com.badlogic.gdx.scenes.scene2d.ui.Value minHeight -> c
    com.badlogic.gdx.scenes.scene2d.ui.Value minWidth -> b
    com.badlogic.gdx.scenes.scene2d.ui.Value prefHeight -> e
    com.badlogic.gdx.scenes.scene2d.ui.Value prefWidth -> d
    com.badlogic.gdx.scenes.scene2d.ui.Value maxHeight -> g
    com.badlogic.gdx.scenes.scene2d.ui.Value maxWidth -> f
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Value$1 -> n.u$a:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Value$2 -> n.u$b:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Value$3 -> n.u$c:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Value$4 -> n.u$d:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Value$5 -> n.u$e:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Value$6 -> n.u$f:
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
com.badlogic.gdx.scenes.scene2d.ui.Value$Fixed -> n.u$g:
    float value -> h
    com.badlogic.gdx.scenes.scene2d.ui.Value$Fixed[] cache -> i
    float get(com.badlogic.gdx.scenes.scene2d.Actor) -> a
    com.badlogic.gdx.scenes.scene2d.ui.Value$Fixed valueOf(float) -> b
com.badlogic.gdx.scenes.scene2d.ui.Widget -> n.v:
    boolean fillParent -> u
    boolean layoutEnabled -> v
    boolean needsLayout -> t
    float getMinHeight() -> a
    float getMinWidth() -> b
    void sizeChanged() -> b0
    float getMaxHeight() -> c
    void invalidateHierarchy() -> d
    void invalidate() -> d0
    float getMaxWidth() -> e
    void layout() -> e0
    void validate() -> f
    float getPrefHeight() -> g
    float getPrefWidth() -> h
com.badlogic.gdx.scenes.scene2d.ui.WidgetGroup -> n.w:
    boolean needsLayout -> A
    boolean fillParent -> B
    boolean layoutEnabled -> C
    void sizeChanged() -> b0
    float getMaxHeight() -> c
    void invalidateHierarchy() -> d
    float getMaxWidth() -> e
    void validate() -> f
    void childrenChanged() -> g0
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> n
    void invalidate() -> v0
    void layout() -> w0
com.badlogic.gdx.scenes.scene2d.ui.Window$WindowStyle -> n.x:
    com.badlogic.gdx.graphics.Color titleFontColor -> a
com.badlogic.gdx.scenes.scene2d.utils.BaseDrawable -> o.a:
    float minHeight -> g
    float minWidth -> f
    float bottomHeight -> e
    float topHeight -> d
    float rightWidth -> c
    java.lang.String name -> a
    float leftWidth -> b
    float getMinHeight() -> a
    float getMinWidth() -> b
    float getRightWidth() -> c
    void setTopHeight(float) -> e
    void setLeftWidth(float) -> f
    void setMinHeight(float) -> g
    float getLeftWidth() -> h
    float getBottomHeight() -> i
    float getTopHeight() -> j
    void setRightWidth(float) -> k
    void setMinWidth(float) -> l
    void setBottomHeight(float) -> m
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> n
    java.lang.String getName() -> o
    void setName(java.lang.String) -> p
com.badlogic.gdx.scenes.scene2d.utils.ChangeListener$ChangeEvent -> o.b:
com.badlogic.gdx.scenes.scene2d.utils.ClickListener -> o.c:
    long tapCountInterval -> l
    long visualPressedTime -> k
    int tapCount -> m
    boolean over -> i
    boolean cancelled -> j
    float touchDownY -> d
    int pressedButton -> f
    float touchDownX -> c
    int button -> g
    float tapSquareSize -> b
    int pressedPointer -> e
    boolean pressed -> h
    long lastTapTime -> n
    float visualPressedDuration -> o
    void enter(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,com.badlogic.gdx.scenes.scene2d.Actor) -> b
    void exit(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,com.badlogic.gdx.scenes.scene2d.Actor) -> c
    boolean touchDown(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> i
    void touchDragged(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int) -> j
    void touchUp(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float,int,int) -> k
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> l
    boolean inTapSquare(float,float) -> m
    void invalidateTapSquare() -> n
    boolean isOver() -> o
    boolean isOver(com.badlogic.gdx.scenes.scene2d.Actor,float,float) -> p
    boolean isPressed() -> q
    boolean isVisualPressed() -> r
    void setVisualPressed(boolean) -> s
com.badlogic.gdx.scenes.scene2d.utils.Drawable -> o.d:
    float getMinHeight() -> a
    float getMinWidth() -> b
    float getRightWidth() -> c
    void setTopHeight(float) -> e
    void setLeftWidth(float) -> f
    void setMinHeight(float) -> g
    float getLeftWidth() -> h
    float getBottomHeight() -> i
    float getTopHeight() -> j
    void setRightWidth(float) -> k
    void setMinWidth(float) -> l
    void setBottomHeight(float) -> m
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> n
com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent -> o.e:
    boolean focused -> i
    com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type type -> j
    com.badlogic.gdx.scenes.scene2d.Actor relatedActor -> k
    void reset() -> a
    void setFocused(boolean) -> n
    void setRelatedActor(com.badlogic.gdx.scenes.scene2d.Actor) -> o
    void setType(com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type) -> p
com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type -> o.e$a:
    com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type keyboard -> a
    com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type scroll -> b
    com.badlogic.gdx.scenes.scene2d.utils.FocusListener$FocusEvent$Type[] $VALUES -> c
com.badlogic.gdx.scenes.scene2d.utils.Layout -> o.f:
    float getMinHeight() -> a
    float getMinWidth() -> b
    float getMaxHeight() -> c
    void invalidateHierarchy() -> d
    float getMaxWidth() -> e
    void validate() -> f
    float getPrefHeight() -> g
    float getPrefWidth() -> h
com.badlogic.gdx.scenes.scene2d.utils.NinePatchDrawable -> o.g:
    com.badlogic.gdx.graphics.g2d.NinePatch patch -> h
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float,float,float,float,float,float) -> d
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> n
    com.badlogic.gdx.graphics.g2d.NinePatch getPatch() -> q
    void setPatch(com.badlogic.gdx.graphics.g2d.NinePatch) -> r
    com.badlogic.gdx.scenes.scene2d.utils.NinePatchDrawable tint(com.badlogic.gdx.graphics.Color) -> s
com.badlogic.gdx.scenes.scene2d.utils.ScissorStack -> o.h:
    com.badlogic.gdx.math.Vector3 tmp -> b
    com.badlogic.gdx.utils.Array scissors -> a
    com.badlogic.gdx.math.Rectangle viewport -> c
    void calculateScissors(com.badlogic.gdx.graphics.Camera,float,float,float,float,com.badlogic.gdx.math.Matrix4,com.badlogic.gdx.math.Rectangle,com.badlogic.gdx.math.Rectangle) -> a
    void fix(com.badlogic.gdx.math.Rectangle) -> b
    com.badlogic.gdx.math.Rectangle popScissors() -> c
    boolean pushScissors(com.badlogic.gdx.math.Rectangle) -> d
com.badlogic.gdx.scenes.scene2d.utils.SpriteDrawable -> o.i:
    com.badlogic.gdx.graphics.g2d.Sprite sprite -> h
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float,float,float,float,float,float) -> d
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> n
    void setSprite(com.badlogic.gdx.graphics.g2d.Sprite) -> q
    com.badlogic.gdx.scenes.scene2d.utils.SpriteDrawable tint(com.badlogic.gdx.graphics.Color) -> r
com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable -> o.j:
    com.badlogic.gdx.graphics.g2d.TextureRegion region -> h
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float,float,float,float,float,float) -> d
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> n
    com.badlogic.gdx.graphics.g2d.TextureRegion getRegion() -> q
    void setRegion(com.badlogic.gdx.graphics.g2d.TextureRegion) -> r
    com.badlogic.gdx.scenes.scene2d.utils.Drawable tint(com.badlogic.gdx.graphics.Color) -> s
com.badlogic.gdx.scenes.scene2d.utils.TiledDrawable -> o.k:
    float scale -> j
    com.badlogic.gdx.graphics.Color color -> i
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float,float,float,float,float,float) -> d
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float) -> n
    com.badlogic.gdx.scenes.scene2d.utils.Drawable tint(com.badlogic.gdx.graphics.Color) -> s
    com.badlogic.gdx.scenes.scene2d.utils.TiledDrawable tint(com.badlogic.gdx.graphics.Color) -> t
com.badlogic.gdx.scenes.scene2d.utils.TransformDrawable -> o.l:
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float,float,float,float,float,float,float,float,float) -> d
com.badlogic.gdx.utils.Array -> p.a:
    com.badlogic.gdx.utils.Array$ArrayIterable iterable -> d
    java.lang.Object[] items -> a
    int size -> b
    boolean ordered -> c
    void add(java.lang.Object) -> a
    void addAll(com.badlogic.gdx.utils.Array) -> b
    void addAll(com.badlogic.gdx.utils.Array,int,int) -> c
    void addAll(java.lang.Object[],int,int) -> d
    void clear() -> e
    boolean contains(java.lang.Object,boolean) -> f
    java.lang.Object[] ensureCapacity(int) -> g
    java.lang.Object first() -> h
    java.lang.Object get(int) -> i
    int indexOf(java.lang.Object,boolean) -> j
    com.badlogic.gdx.utils.Array$ArrayIterator iterator() -> k
    java.lang.Object peek() -> l
    java.lang.Object pop() -> m
    java.lang.Object removeIndex(int) -> n
    void removeRange(int,int) -> o
    boolean removeValue(java.lang.Object,boolean) -> p
    java.lang.Object[] resize(int) -> q
    void sort() -> r
    void sort(java.util.Comparator) -> s
    java.lang.Object[] toArray(java.lang.Class) -> t
    void truncate(int) -> u
    com.badlogic.gdx.utils.Array with(java.lang.Object[]) -> v
com.badlogic.gdx.utils.Array$ArrayIterable -> p.a$a:
    com.badlogic.gdx.utils.Array array -> a
    com.badlogic.gdx.utils.Array$ArrayIterator iterator2 -> d
    com.badlogic.gdx.utils.Array$ArrayIterator iterator1 -> c
    boolean allowRemove -> b
    com.badlogic.gdx.utils.Array$ArrayIterator iterator() -> a
com.badlogic.gdx.utils.Array$ArrayIterator -> p.a$b:
    com.badlogic.gdx.utils.Array array -> a
    boolean allowRemove -> b
    int index -> c
    boolean valid -> d
    com.badlogic.gdx.utils.Array$ArrayIterator iterator() -> a
com.badlogic.gdx.utils.ArrayMap -> p.b:
    java.lang.Object[] values -> b
    java.lang.Object[] keys -> a
    com.badlogic.gdx.utils.ArrayMap$Entries entries2 -> f
    int size -> c
    boolean ordered -> d
    com.badlogic.gdx.utils.ArrayMap$Entries entries1 -> e
    com.badlogic.gdx.utils.ArrayMap$Entries entries() -> a
    java.lang.Object get(java.lang.Object) -> b
    java.lang.Object get(java.lang.Object,java.lang.Object) -> c
    int indexOfKey(java.lang.Object) -> d
    int put(java.lang.Object,java.lang.Object) -> e
    void removeIndex(int) -> f
    void resize(int) -> g
com.badlogic.gdx.utils.ArrayMap$Entries -> p.b$a:
    com.badlogic.gdx.utils.ArrayMap map -> a
    com.badlogic.gdx.utils.ObjectMap$Entry entry -> b
    int index -> c
    boolean valid -> d
    com.badlogic.gdx.utils.ObjectMap$Entry next() -> a
com.badlogic.gdx.utils.BufferUtils -> com.badlogic.gdx.utils.BufferUtils:
    com.badlogic.gdx.utils.Array unsafeBuffers -> a
    int allocatedUnsafe -> b
    void copy(float[],java.nio.Buffer,int,int) -> a
    void disposeUnsafeByteBuffer(java.nio.ByteBuffer) -> b
    java.nio.ByteBuffer newByteBuffer(int) -> c
    java.nio.FloatBuffer newFloatBuffer(int) -> d
    java.nio.IntBuffer newIntBuffer(int) -> e
    java.nio.ByteBuffer newUnsafeByteBuffer(int) -> f
com.badlogic.gdx.utils.Collections -> p.c:
    boolean allocateIterators -> a
com.badlogic.gdx.utils.ComparableTimSort -> p.d:
    int[] runBase -> f
    int[] runLen -> g
    java.lang.Object[] tmp -> c
    int tmpCount -> d
    int stackSize -> e
    int minGallop -> b
    void binarySort(java.lang.Object[],int,int,int) -> a
    int countRunAndMakeAscending(java.lang.Object[],int,int) -> b
    void doSort(java.lang.Object[],int,int) -> c
    java.lang.Object[] ensureCapacity(int) -> d
    int gallopLeft(java.lang.Comparable,java.lang.Object[],int,int,int) -> e
    int gallopRight(java.lang.Comparable,java.lang.Object[],int,int,int) -> f
    void mergeAt(int) -> g
    void mergeCollapse() -> h
    void mergeForceCollapse() -> i
    void mergeHi(int,int,int,int) -> j
    void mergeLo(int,int,int,int) -> k
    int minRunLength(int) -> l
    void pushRun(int,int) -> m
    void rangeCheck(int,int,int) -> n
    void reverseRange(java.lang.Object[],int,int) -> o
com.badlogic.gdx.utils.DelayedRemovalArray -> p.e:
    com.badlogic.gdx.utils.IntArray remove -> f
    int clear -> g
    int iterating -> e
    void clear() -> e
    java.lang.Object pop() -> m
    java.lang.Object removeIndex(int) -> n
    void removeRange(int,int) -> o
    boolean removeValue(java.lang.Object,boolean) -> p
    void sort() -> r
    void sort(java.util.Comparator) -> s
    void truncate(int) -> u
    void begin() -> w
    void end() -> x
    void remove(int) -> y
com.badlogic.gdx.utils.Disposable -> p.f:
    void dispose() -> a
com.badlogic.gdx.utils.FloatArray -> p.g:
    float[] items -> a
    int size -> b
    boolean ordered -> c
    void add(float) -> a
    void addAll(com.badlogic.gdx.utils.FloatArray) -> b
    void addAll(com.badlogic.gdx.utils.FloatArray,int,int) -> c
    void addAll(float[],int,int) -> d
    void clear() -> e
    float[] ensureCapacity(int) -> f
    float first() -> g
    float get(int) -> h
    boolean notEmpty() -> i
    void removeRange(int,int) -> j
    float[] resize(int) -> k
    void truncate(int) -> l
com.badlogic.gdx.utils.GdxNativesLoader -> p.h:
    boolean disableNativesLoading -> a
    boolean nativesLoaded -> b
    void load() -> a
com.badlogic.gdx.utils.GdxRuntimeException -> p.i:
com.badlogic.gdx.utils.IntArray -> p.j:
    int[] items -> a
    int size -> b
    boolean ordered -> c
    void add(int) -> a
    void add(int,int) -> b
    void clear() -> c
    int[] ensureCapacity(int) -> d
    int get(int) -> e
    void insert(int,int) -> f
    int peek() -> g
    int pop() -> h
    int[] resize(int) -> i
    void set(int,int) -> j
com.badlogic.gdx.utils.IntMap -> p.k:
    java.lang.Object[] valueTable -> c
    int[] keyTable -> b
    com.badlogic.gdx.utils.IntMap$Entries entries1 -> j
    com.badlogic.gdx.utils.IntMap$Entries entries2 -> k
    java.lang.Object zeroValue -> d
    float loadFactor -> f
    int shift -> h
    int mask -> i
    boolean hasZeroValue -> e
    int threshold -> g
    int size -> a
    com.badlogic.gdx.utils.IntMap$Entries entries() -> a
    java.lang.Object get(int) -> b
    java.lang.Object get(int,java.lang.Object) -> c
    int locateKey(int) -> d
    int place(int) -> e
    java.lang.Object put(int,java.lang.Object) -> f
    void putResize(int,java.lang.Object) -> g
    void resize(int) -> h
com.badlogic.gdx.utils.IntMap$Entries -> p.k$a:
    com.badlogic.gdx.utils.IntMap$Entry entry -> f
    void reset() -> b
    com.badlogic.gdx.utils.IntMap$Entry next() -> c
com.badlogic.gdx.utils.IntMap$Entry -> p.k$b:
    java.lang.Object value -> b
    int key -> a
com.badlogic.gdx.utils.IntMap$MapIterator -> p.k$c:
    boolean valid -> e
    int currentIndex -> d
    boolean hasNext -> a
    int nextIndex -> c
    com.badlogic.gdx.utils.IntMap map -> b
    void findNextIndex() -> a
    void reset() -> b
com.badlogic.gdx.utils.IntSet -> p.l:
    int[] keyTable -> b
    float loadFactor -> d
    int shift -> f
    int mask -> g
    int threshold -> e
    boolean hasZeroValue -> c
    int size -> a
    boolean add(int) -> a
    void addResize(int) -> b
    boolean contains(int) -> c
    int locateKey(int) -> d
    int place(int) -> e
    boolean remove(int) -> f
    void resize(int) -> g
com.badlogic.gdx.utils.Json -> p.m:
    com.badlogic.gdx.utils.ObjectMap classToSerializer -> m
    com.badlogic.gdx.utils.ObjectMap classToTag -> l
    com.badlogic.gdx.utils.ObjectMap tagToClass -> k
    com.badlogic.gdx.utils.ObjectMap typeToFields -> j
    com.badlogic.gdx.utils.ObjectMap classToDefaultValues -> n
    java.lang.Object[] equals2 -> p
    com.badlogic.gdx.utils.JsonWriter$OutputType outputType -> c
    com.badlogic.gdx.utils.Json$Serializer defaultSerializer -> i
    java.lang.Object[] equals1 -> o
    boolean ignoreDeprecated -> e
    boolean readDeprecated -> f
    java.lang.String typeName -> a
    boolean enumNames -> g
    boolean sortFields -> h
    boolean usePrototypes -> b
    boolean ignoreUnknownFields -> d
    void addClassTag(java.lang.String,java.lang.Class) -> a
    java.lang.String convertToString(java.lang.Enum) -> b
    void copyFields(java.lang.Object,java.lang.Object) -> c
    java.lang.Object fromJson(java.lang.Class,com.badlogic.gdx.files.FileHandle) -> d
    java.lang.Class getClass(java.lang.String) -> e
    com.badlogic.gdx.utils.OrderedMap getFields(java.lang.Class) -> f
    boolean ignoreUnknownField(java.lang.Class,java.lang.String) -> g
    java.lang.Object newInstance(java.lang.Class) -> h
    void readFields(java.lang.Object,com.badlogic.gdx.utils.JsonValue) -> i
    java.lang.Object readValue(java.lang.Class,java.lang.Class,com.badlogic.gdx.utils.JsonValue) -> j
    java.lang.Object readValue(java.lang.Class,com.badlogic.gdx.utils.JsonValue) -> k
    java.lang.Object readValue(java.lang.String,java.lang.Class,java.lang.Object,com.badlogic.gdx.utils.JsonValue) -> l
    java.lang.Object readValue(java.lang.String,java.lang.Class,com.badlogic.gdx.utils.JsonValue) -> m
    void setSerializer(java.lang.Class,com.badlogic.gdx.utils.Json$Serializer) -> n
    void setTypeName(java.lang.String) -> o
    void setUsePrototypes(boolean) -> p
    void sortFields(java.lang.Class,com.badlogic.gdx.utils.Array) -> q
com.badlogic.gdx.utils.Json$FieldMetadata -> p.m$a:
    com.badlogic.gdx.utils.reflect.Field field -> a
    java.lang.Class elementType -> b
    boolean deprecated -> c
com.badlogic.gdx.utils.Json$ReadOnlySerializer -> p.m$b:
com.badlogic.gdx.utils.Json$Serializable -> p.m$c:
    void read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue) -> a
com.badlogic.gdx.utils.Json$Serializer -> p.m$d:
    java.lang.Object read(com.badlogic.gdx.utils.Json,com.badlogic.gdx.utils.JsonValue,java.lang.Class) -> a
com.badlogic.gdx.utils.JsonReader -> p.n:
    short[] _json_index_offsets -> j
    com.badlogic.gdx.utils.Array elements -> a
    byte[] _json_trans_targs -> l
    byte[] _json_indicies -> k
    char[] _json_trans_keys -> g
    byte[] _json_eof_actions -> n
    byte[] _json_trans_actions -> m
    short[] _json_key_offsets -> f
    com.badlogic.gdx.utils.JsonValue current -> d
    byte[] _json_single_lengths -> h
    com.badlogic.gdx.utils.Array lastChild -> b
    com.badlogic.gdx.utils.JsonValue root -> c
    byte[] _json_range_lengths -> i
    byte[] _json_actions -> e
    void addChild(java.lang.String,com.badlogic.gdx.utils.JsonValue) -> a
    void bool(java.lang.String,boolean) -> b
    byte[] init__json_actions_0() -> c
    byte[] init__json_eof_actions_0() -> d
    short[] init__json_index_offsets_0() -> e
    byte[] init__json_indicies_0() -> f
    short[] init__json_key_offsets_0() -> g
    byte[] init__json_range_lengths_0() -> h
    byte[] init__json_single_lengths_0() -> i
    byte[] init__json_trans_actions_0() -> j
    char[] init__json_trans_keys_0() -> k
    byte[] init__json_trans_targs_0() -> l
    void number(java.lang.String,double,java.lang.String) -> m
    void number(java.lang.String,long,java.lang.String) -> n
    com.badlogic.gdx.utils.JsonValue parse(com.badlogic.gdx.files.FileHandle) -> o
    com.badlogic.gdx.utils.JsonValue parse(java.io.Reader) -> p
    com.badlogic.gdx.utils.JsonValue parse(char[],int,int) -> q
    void pop() -> r
    void startArray(java.lang.String) -> s
    void startObject(java.lang.String) -> t
    void string(java.lang.String,java.lang.String) -> u
    java.lang.String unescape(java.lang.String) -> v
com.badlogic.gdx.utils.JsonValue -> p.o:
    com.badlogic.gdx.utils.JsonValue$ValueType type -> a
    int size -> j
    double doubleValue -> c
    long longValue -> d
    com.badlogic.gdx.utils.JsonValue next -> h
    java.lang.String stringValue -> b
    com.badlogic.gdx.utils.JsonValue prev -> i
    java.lang.String name -> e
    com.badlogic.gdx.utils.JsonValue child -> f
    com.badlogic.gdx.utils.JsonValue parent -> g
    java.lang.String prettyPrint(com.badlogic.gdx.utils.JsonValue$PrettyPrintSettings) -> A
    java.lang.String prettyPrint(com.badlogic.gdx.utils.JsonWriter$OutputType,int) -> B
    void prettyPrint(com.badlogic.gdx.utils.JsonValue,com.badlogic.gdx.utils.StringBuilder,int,com.badlogic.gdx.utils.JsonValue$PrettyPrintSettings) -> C
    void set(double,java.lang.String) -> D
    void set(long,java.lang.String) -> E
    void set(java.lang.String) -> F
    void set(boolean) -> G
    void setName(java.lang.String) -> H
    java.lang.String trace() -> I
    boolean asBoolean() -> a
    byte asByte() -> b
    double asDouble() -> c
    float asFloat() -> d
    int asInt() -> e
    long asLong() -> f
    short asShort() -> g
    java.lang.String asString() -> h
    com.badlogic.gdx.utils.JsonValue get(java.lang.String) -> i
    com.badlogic.gdx.utils.JsonValue getChild(java.lang.String) -> j
    java.lang.String getString(java.lang.String,java.lang.String) -> k
    boolean has(java.lang.String) -> l
    void indent(int,com.badlogic.gdx.utils.StringBuilder) -> m
    boolean isArray() -> n
    boolean isBoolean() -> o
    boolean isDouble() -> p
    boolean isFlat(com.badlogic.gdx.utils.JsonValue) -> q
    boolean isLong() -> r
    boolean isNull() -> s
    boolean isNumber() -> t
    boolean isNumeric(com.badlogic.gdx.utils.JsonValue) -> u
    boolean isObject() -> v
    boolean isString() -> w
    boolean isValue() -> x
    com.badlogic.gdx.utils.JsonValue$JsonIterator iterator() -> y
    java.lang.String name() -> z
com.badlogic.gdx.utils.JsonValue$1 -> p.o$a:
    int[] $SwitchMap$com$badlogic$gdx$utils$JsonValue$ValueType -> a
com.badlogic.gdx.utils.JsonValue$JsonIterator -> p.o$b:
    com.badlogic.gdx.utils.JsonValue entry -> a
    com.badlogic.gdx.utils.JsonValue current -> b
    com.badlogic.gdx.utils.JsonValue this$0 -> c
    com.badlogic.gdx.utils.JsonValue next() -> a
com.badlogic.gdx.utils.JsonValue$PrettyPrintSettings -> p.o$c:
    com.badlogic.gdx.utils.JsonWriter$OutputType outputType -> a
    int singleLineColumns -> b
    boolean wrapNumericArrays -> c
com.badlogic.gdx.utils.JsonValue$ValueType -> p.o$d:
    com.badlogic.gdx.utils.JsonValue$ValueType doubleValue -> d
    com.badlogic.gdx.utils.JsonValue$ValueType stringValue -> c
    com.badlogic.gdx.utils.JsonValue$ValueType array -> b
    com.badlogic.gdx.utils.JsonValue$ValueType[] $VALUES -> h
    com.badlogic.gdx.utils.JsonValue$ValueType object -> a
    com.badlogic.gdx.utils.JsonValue$ValueType nullValue -> g
    com.badlogic.gdx.utils.JsonValue$ValueType booleanValue -> f
    com.badlogic.gdx.utils.JsonValue$ValueType longValue -> e
com.badlogic.gdx.utils.JsonWriter$1 -> p.p:
    int[] $SwitchMap$com$badlogic$gdx$utils$JsonWriter$OutputType -> a
com.badlogic.gdx.utils.JsonWriter$OutputType -> p.q:
    java.util.regex.Pattern minimalValuePattern -> f
    com.badlogic.gdx.utils.JsonWriter$OutputType javascript -> b
    com.badlogic.gdx.utils.JsonWriter$OutputType json -> a
    java.util.regex.Pattern minimalNamePattern -> e
    com.badlogic.gdx.utils.JsonWriter$OutputType minimal -> c
    java.util.regex.Pattern javascriptPattern -> d
    com.badlogic.gdx.utils.JsonWriter$OutputType[] $VALUES -> g
    java.lang.String quoteName(java.lang.String) -> a
    java.lang.String quoteValue(java.lang.Object) -> b
com.badlogic.gdx.utils.LongMap -> p.r:
    com.badlogic.gdx.utils.LongMap$Entries entries2 -> k
    com.badlogic.gdx.utils.LongMap$Entries entries1 -> j
    java.lang.Object[] valueTable -> c
    java.lang.Object zeroValue -> d
    float loadFactor -> f
    int shift -> h
    long[] keyTable -> b
    int mask -> i
    boolean hasZeroValue -> e
    int threshold -> g
    int size -> a
    com.badlogic.gdx.utils.LongMap$Entries entries() -> a
    java.lang.Object get(long) -> b
    java.lang.Object get(long,java.lang.Object) -> c
    int locateKey(long) -> d
    int place(long) -> e
    java.lang.Object put(long,java.lang.Object) -> f
    void putResize(long,java.lang.Object) -> g
    void resize(int) -> h
com.badlogic.gdx.utils.LongMap$Entries -> p.r$a:
    com.badlogic.gdx.utils.LongMap$Entry entry -> f
    void reset() -> b
    com.badlogic.gdx.utils.LongMap$Entry next() -> c
com.badlogic.gdx.utils.LongMap$Entry -> p.r$b:
    java.lang.Object value -> b
    long key -> a
com.badlogic.gdx.utils.LongMap$MapIterator -> p.r$c:
    boolean valid -> e
    int currentIndex -> d
    boolean hasNext -> a
    com.badlogic.gdx.utils.LongMap map -> b
    int nextIndex -> c
    void findNextIndex() -> a
    void reset() -> b
com.badlogic.gdx.utils.NumberUtils -> p.s:
    int floatToIntBits(float) -> a
    int floatToIntColor(float) -> b
    int floatToRawIntBits(float) -> c
    float intToFloatColor(int) -> d
com.badlogic.gdx.utils.ObjectFloatMap -> p.t:
    java.lang.Object[] keyTable -> b
    float loadFactor -> d
    int shift -> f
    com.badlogic.gdx.utils.ObjectFloatMap$Entries entries2 -> i
    int mask -> g
    com.badlogic.gdx.utils.ObjectFloatMap$Entries entries1 -> h
    float[] valueTable -> c
    int threshold -> e
    int size -> a
    boolean containsKey(java.lang.Object) -> a
    com.badlogic.gdx.utils.ObjectFloatMap$Entries entries() -> b
    float get(java.lang.Object,float) -> c
    com.badlogic.gdx.utils.ObjectFloatMap$Entries iterator() -> d
    int locateKey(java.lang.Object) -> e
    int place(java.lang.Object) -> f
    void put(java.lang.Object,float) -> g
    void putResize(java.lang.Object,float) -> h
    void resize(int) -> i
    java.lang.String toString(java.lang.String,boolean) -> j
com.badlogic.gdx.utils.ObjectFloatMap$Entries -> p.t$a:
    com.badlogic.gdx.utils.ObjectFloatMap$Entry entry -> f
    void reset() -> b
    com.badlogic.gdx.utils.ObjectFloatMap$Entries iterator() -> c
    com.badlogic.gdx.utils.ObjectFloatMap$Entry next() -> d
com.badlogic.gdx.utils.ObjectFloatMap$Entry -> p.t$b:
    float value -> b
    java.lang.Object key -> a
com.badlogic.gdx.utils.ObjectFloatMap$MapIterator -> p.t$c:
    boolean valid -> e
    int currentIndex -> d
    boolean hasNext -> a
    int nextIndex -> c
    com.badlogic.gdx.utils.ObjectFloatMap map -> b
    void findNextIndex() -> a
    void reset() -> b
com.badlogic.gdx.utils.ObjectIntMap -> p.u:
    java.lang.Object[] keyTable -> b
    int[] valueTable -> c
    com.badlogic.gdx.utils.ObjectIntMap$Entries entries1 -> h
    float loadFactor -> d
    int shift -> f
    com.badlogic.gdx.utils.ObjectIntMap$Entries entries2 -> i
    int mask -> g
    int threshold -> e
    int size -> a
    boolean containsKey(java.lang.Object) -> a
    com.badlogic.gdx.utils.ObjectIntMap$Entries entries() -> b
    int get(java.lang.Object,int) -> c
    com.badlogic.gdx.utils.ObjectIntMap$Entries iterator() -> d
    int locateKey(java.lang.Object) -> e
    int place(java.lang.Object) -> f
    void put(java.lang.Object,int) -> g
    void putResize(java.lang.Object,int) -> h
    void resize(int) -> i
    java.lang.String toString(java.lang.String,boolean) -> j
com.badlogic.gdx.utils.ObjectIntMap$Entries -> p.u$a:
    com.badlogic.gdx.utils.ObjectIntMap$Entry entry -> f
    void reset() -> b
    com.badlogic.gdx.utils.ObjectIntMap$Entries iterator() -> c
    com.badlogic.gdx.utils.ObjectIntMap$Entry next() -> d
com.badlogic.gdx.utils.ObjectIntMap$Entry -> p.u$b:
    java.lang.Object key -> a
    int value -> b
com.badlogic.gdx.utils.ObjectIntMap$MapIterator -> p.u$c:
    boolean valid -> e
    int currentIndex -> d
    com.badlogic.gdx.utils.ObjectIntMap map -> b
    boolean hasNext -> a
    int nextIndex -> c
    void findNextIndex() -> a
    void reset() -> b
com.badlogic.gdx.utils.ObjectMap -> p.v:
    java.lang.Object[] keyTable -> b
    java.lang.Object[] valueTable -> c
    com.badlogic.gdx.utils.ObjectMap$Entries entries1 -> h
    com.badlogic.gdx.utils.ObjectMap$Entries entries2 -> i
    float loadFactor -> d
    int shift -> f
    int mask -> g
    int threshold -> e
    com.badlogic.gdx.utils.ObjectMap$Keys keys1 -> j
    com.badlogic.gdx.utils.ObjectMap$Keys keys2 -> k
    java.lang.Object dummy -> l
    int size -> a
    void clear() -> a
    com.badlogic.gdx.utils.ObjectMap$Entries entries() -> b
    java.lang.Object get(java.lang.Object) -> c
    java.lang.Object get(java.lang.Object,java.lang.Object) -> d
    com.badlogic.gdx.utils.ObjectMap$Entries iterator() -> e
    com.badlogic.gdx.utils.ObjectMap$Keys keys() -> f
    int locateKey(java.lang.Object) -> g
    int place(java.lang.Object) -> h
    java.lang.Object put(java.lang.Object,java.lang.Object) -> i
    void putResize(java.lang.Object,java.lang.Object) -> j
    java.lang.Object remove(java.lang.Object) -> k
    void resize(int) -> l
    java.lang.String toString(java.lang.String,boolean) -> m
com.badlogic.gdx.utils.ObjectMap$Entries -> p.v$a:
    com.badlogic.gdx.utils.ObjectMap$Entry entry -> f
    void reset() -> b
    com.badlogic.gdx.utils.ObjectMap$Entries iterator() -> c
    com.badlogic.gdx.utils.ObjectMap$Entry next() -> d
com.badlogic.gdx.utils.ObjectMap$Entry -> p.v$b:
    java.lang.Object value -> b
    java.lang.Object key -> a
com.badlogic.gdx.utils.ObjectMap$Keys -> p.v$c:
    void reset() -> b
    com.badlogic.gdx.utils.ObjectMap$Keys iterator() -> c
com.badlogic.gdx.utils.ObjectMap$MapIterator -> p.v$d:
    boolean valid -> e
    int currentIndex -> d
    boolean hasNext -> a
    int nextIndex -> c
    com.badlogic.gdx.utils.ObjectMap map -> b
    void findNextIndex() -> a
    void reset() -> b
com.badlogic.gdx.utils.ObjectSet -> p.w:
    java.lang.Object[] keyTable -> b
    int mask -> f
    com.badlogic.gdx.utils.ObjectSet$ObjectSetIterator iterator1 -> g
    float loadFactor -> c
    com.badlogic.gdx.utils.ObjectSet$ObjectSetIterator iterator2 -> h
    int threshold -> d
    int shift -> e
    int size -> a
    boolean add(java.lang.Object) -> a
    void addResize(java.lang.Object) -> b
    boolean contains(java.lang.Object) -> c
    void ensureCapacity(int) -> d
    com.badlogic.gdx.utils.ObjectSet$ObjectSetIterator iterator() -> e
    int locateKey(java.lang.Object) -> f
    int place(java.lang.Object) -> g
    void resize(int) -> h
    int tableSize(int,float) -> i
    java.lang.String toString(java.lang.String) -> j
com.badlogic.gdx.utils.ObjectSet$ObjectSetIterator -> p.w$a:
    com.badlogic.gdx.utils.ObjectSet set -> b
    boolean valid -> e
    int currentIndex -> d
    boolean hasNext -> a
    int nextIndex -> c
    void findNextIndex() -> a
    com.badlogic.gdx.utils.ObjectSet$ObjectSetIterator iterator() -> b
    void reset() -> c
com.badlogic.gdx.utils.OrderedMap -> p.x:
    com.badlogic.gdx.utils.Array keys -> m
    void clear() -> a
    com.badlogic.gdx.utils.ObjectMap$Entries entries() -> b
    com.badlogic.gdx.utils.ObjectMap$Entries iterator() -> e
    com.badlogic.gdx.utils.ObjectMap$Keys keys() -> f
    java.lang.Object put(java.lang.Object,java.lang.Object) -> i
    java.lang.Object remove(java.lang.Object) -> k
    java.lang.String toString(java.lang.String,boolean) -> m
    java.lang.Object removeIndex(int) -> n
com.badlogic.gdx.utils.OrderedMap$OrderedMapEntries -> p.x$a:
    com.badlogic.gdx.utils.Array keys -> g
    void reset() -> b
    com.badlogic.gdx.utils.ObjectMap$Entry next() -> d
com.badlogic.gdx.utils.OrderedMap$OrderedMapKeys -> p.x$b:
    com.badlogic.gdx.utils.Array keys -> f
    void reset() -> b
com.badlogic.gdx.utils.Pool -> p.y:
    com.badlogic.gdx.utils.Array freeObjects -> c
    int peak -> b
    int max -> a
    void discard(java.lang.Object) -> a
    void free(java.lang.Object) -> b
    void freeAll(com.badlogic.gdx.utils.Array) -> c
    java.lang.Object newObject() -> d
    java.lang.Object obtain() -> e
    void reset(java.lang.Object) -> f
com.badlogic.gdx.utils.Pool$Poolable -> p.y$a:
    void reset() -> a
com.badlogic.gdx.utils.Pools -> p.z:
    com.badlogic.gdx.utils.ObjectMap typePools -> a
    void free(java.lang.Object) -> a
    void freeAll(com.badlogic.gdx.utils.Array,boolean) -> b
    com.badlogic.gdx.utils.Pool get(java.lang.Class) -> c
    com.badlogic.gdx.utils.Pool get(java.lang.Class,int) -> d
    java.lang.Object obtain(java.lang.Class) -> e
com.badlogic.gdx.utils.Queue -> p.a0:
    java.lang.Object[] values -> a
    int size -> d
    int head -> b
    com.badlogic.gdx.utils.Queue$QueueIterable iterable -> e
    int tail -> c
    void addLast(java.lang.Object) -> a
    java.lang.Object get(int) -> b
    java.lang.Object removeIndex(int) -> c
    void resize(int) -> d
com.badlogic.gdx.utils.Queue$QueueIterable -> p.a0$a:
    boolean allowRemove -> b
    com.badlogic.gdx.utils.Queue queue -> a
    com.badlogic.gdx.utils.Queue$QueueIterator iterator1 -> c
    com.badlogic.gdx.utils.Queue$QueueIterator iterator2 -> d
com.badlogic.gdx.utils.Queue$QueueIterator -> p.a0$b:
    boolean allowRemove -> b
    int index -> c
    com.badlogic.gdx.utils.Queue queue -> a
    boolean valid -> d
com.badlogic.gdx.utils.ReflectionPool -> p.b0:
    com.badlogic.gdx.utils.reflect.Constructor constructor -> d
    java.lang.Object newObject() -> d
    com.badlogic.gdx.utils.reflect.Constructor findConstructor(java.lang.Class) -> g
com.badlogic.gdx.utils.Scaling -> p.c0:
    com.badlogic.gdx.utils.Scaling stretch -> g
    com.badlogic.gdx.utils.Scaling fillY -> f
    com.badlogic.gdx.math.Vector2 temp -> a
    com.badlogic.gdx.utils.Scaling fillX -> e
    com.badlogic.gdx.utils.Scaling fill -> d
    com.badlogic.gdx.utils.Scaling contain -> c
    com.badlogic.gdx.utils.Scaling fit -> b
    com.badlogic.gdx.utils.Scaling none -> j
    com.badlogic.gdx.utils.Scaling stretchY -> i
    com.badlogic.gdx.utils.Scaling stretchX -> h
    com.badlogic.gdx.math.Vector2 apply(float,float,float,float) -> a
com.badlogic.gdx.utils.Scaling$1 -> p.c0$a:
    com.badlogic.gdx.math.Vector2 apply(float,float,float,float) -> a
com.badlogic.gdx.utils.Scaling$2 -> p.c0$b:
    com.badlogic.gdx.math.Vector2 apply(float,float,float,float) -> a
com.badlogic.gdx.utils.Scaling$3 -> p.c0$c:
    com.badlogic.gdx.math.Vector2 apply(float,float,float,float) -> a
com.badlogic.gdx.utils.Scaling$4 -> p.c0$d:
    com.badlogic.gdx.math.Vector2 apply(float,float,float,float) -> a
com.badlogic.gdx.utils.Scaling$5 -> p.c0$e:
    com.badlogic.gdx.math.Vector2 apply(float,float,float,float) -> a
com.badlogic.gdx.utils.Scaling$6 -> p.c0$f:
    com.badlogic.gdx.math.Vector2 apply(float,float,float,float) -> a
com.badlogic.gdx.utils.Scaling$7 -> p.c0$g:
    com.badlogic.gdx.math.Vector2 apply(float,float,float,float) -> a
com.badlogic.gdx.utils.Scaling$8 -> p.c0$h:
    com.badlogic.gdx.math.Vector2 apply(float,float,float,float) -> a
com.badlogic.gdx.utils.Scaling$9 -> p.c0$i:
    com.badlogic.gdx.math.Vector2 apply(float,float,float,float) -> a
com.badlogic.gdx.utils.ScreenUtils -> p.d0:
    void clear(float,float,float,float) -> a
    void clear(float,float,float,float,boolean) -> b
com.badlogic.gdx.utils.SerializationException -> p.e0:
    com.badlogic.gdx.utils.StringBuilder trace -> a
    void addTrace(java.lang.String) -> a
com.badlogic.gdx.utils.SharedLibraryLoadRuntimeException -> p.f0:
com.badlogic.gdx.utils.SharedLibraryLoader -> p.g0:
    java.util.Random random -> j
    boolean isIos -> e
    boolean isAndroid -> f
    java.lang.String nativesJar -> a
    boolean isARM -> g
    boolean is64Bit -> h
    boolean isWindows -> b
    boolean isLinux -> c
    boolean isMac -> d
    java.util.HashSet loadedLibraries -> i
    void closeQuietly(java.io.Closeable) -> a
    java.lang.String crc(java.io.InputStream) -> b
    java.io.File extractFile(java.lang.String,java.lang.String,java.io.File) -> c
    boolean isLoaded(java.lang.String) -> d
    void load(java.lang.String) -> e
    java.lang.Throwable loadFile(java.lang.String,java.lang.String,java.io.File) -> f
    void loadFile(java.lang.String) -> g
    java.lang.String mapLibraryName(java.lang.String) -> h
    java.io.InputStream readFile(java.lang.String) -> i
    void setLoaded(java.lang.String) -> j
com.badlogic.gdx.utils.SnapshotArray -> p.h0:
    java.lang.Object[] snapshot -> e
    int snapshots -> g
    java.lang.Object[] recycled -> f
    void clear() -> e
    java.lang.Object pop() -> m
    java.lang.Object removeIndex(int) -> n
    void removeRange(int,int) -> o
    boolean removeValue(java.lang.Object,boolean) -> p
    void sort() -> r
    void sort(java.util.Comparator) -> s
    void truncate(int) -> u
    java.lang.Object[] begin() -> w
    void end() -> x
    void modified() -> y
com.badlogic.gdx.utils.Sort -> p.i0:
    com.badlogic.gdx.utils.TimSort timSort -> a
    com.badlogic.gdx.utils.Sort instance -> c
    com.badlogic.gdx.utils.ComparableTimSort comparableTimSort -> b
    com.badlogic.gdx.utils.Sort instance() -> a
    void sort(java.lang.Object[],int,int) -> b
    void sort(java.lang.Object[],java.util.Comparator,int,int) -> c
com.badlogic.gdx.utils.StreamUtils -> p.j0:
    byte[] EMPTY_BYTES -> a
    void closeQuietly(java.io.Closeable) -> a
    void copyStream(java.io.InputStream,java.io.OutputStream) -> b
    void copyStream(java.io.InputStream,java.io.OutputStream,byte[]) -> c
    byte[] copyStreamToByteArray(java.io.InputStream,int) -> d
com.badlogic.gdx.utils.StreamUtils$OptimizedByteArrayOutputStream -> p.j0$a:
com.badlogic.gdx.utils.StringBuilder -> p.k0:
    char[] chars -> a
    char[] digits -> c
    int length -> b
    void move(int,int) -> A
    int numChars(int,int) -> B
    int numChars(long,int) -> C
    com.badlogic.gdx.utils.StringBuilder replace(char,java.lang.String) -> D
    void replace0(int,int,java.lang.String) -> E
    void setLength(int) -> F
    java.lang.String substring(int,int) -> G
    com.badlogic.gdx.utils.StringBuilder append(char) -> a
    com.badlogic.gdx.utils.StringBuilder append(double) -> b
    com.badlogic.gdx.utils.StringBuilder append(float) -> c
    com.badlogic.gdx.utils.StringBuilder append(int) -> d
    com.badlogic.gdx.utils.StringBuilder append(int,int) -> e
    com.badlogic.gdx.utils.StringBuilder append(int,int,char) -> f
    com.badlogic.gdx.utils.StringBuilder append(long) -> g
    com.badlogic.gdx.utils.StringBuilder append(long,int) -> h
    com.badlogic.gdx.utils.StringBuilder append(long,int,char) -> i
    com.badlogic.gdx.utils.StringBuilder append(java.lang.CharSequence) -> j
    com.badlogic.gdx.utils.StringBuilder append(java.lang.CharSequence,int,int) -> k
    com.badlogic.gdx.utils.StringBuilder append(java.lang.Object) -> l
    com.badlogic.gdx.utils.StringBuilder append(java.lang.String) -> m
    com.badlogic.gdx.utils.StringBuilder append(com.badlogic.gdx.utils.StringBuilder) -> n
    com.badlogic.gdx.utils.StringBuilder append(boolean) -> o
    com.badlogic.gdx.utils.StringBuilder append(char[]) -> p
    void append0(char) -> q
    void append0(java.lang.CharSequence,int,int) -> r
    void append0(java.lang.String) -> s
    void append0(char[]) -> t
    void append0(char[],int,int) -> u
    void appendNull() -> v
    void enlargeBuffer(int) -> w
    int indexOf(java.lang.String) -> x
    int indexOf(java.lang.String,int) -> y
    void insert0(int,java.lang.String) -> z
com.badlogic.gdx.utils.TimSort -> p.l0:
    java.lang.Object[] tmp -> d
    int[] runBase -> g
    int[] runLen -> h
    int stackSize -> f
    int tmpCount -> e
    int minGallop -> c
    java.util.Comparator c -> b
    void binarySort(java.lang.Object[],int,int,int,java.util.Comparator) -> a
    int countRunAndMakeAscending(java.lang.Object[],int,int,java.util.Comparator) -> b
    void doSort(java.lang.Object[],java.util.Comparator,int,int) -> c
    java.lang.Object[] ensureCapacity(int) -> d
    int gallopLeft(java.lang.Object,java.lang.Object[],int,int,int,java.util.Comparator) -> e
    int gallopRight(java.lang.Object,java.lang.Object[],int,int,int,java.util.Comparator) -> f
    void mergeAt(int) -> g
    void mergeCollapse() -> h
    void mergeForceCollapse() -> i
    void mergeHi(int,int,int,int) -> j
    void mergeLo(int,int,int,int) -> k
    int minRunLength(int) -> l
    void pushRun(int,int) -> m
    void rangeCheck(int,int,int) -> n
    void reverseRange(java.lang.Object[],int,int) -> o
com.badlogic.gdx.utils.TimeUtils -> p.m0:
    long millis() -> a
    long nanoTime() -> b
com.badlogic.gdx.utils.Timer -> p.n0:
    com.badlogic.gdx.utils.Timer$TimerThread thread -> c
    com.badlogic.gdx.utils.Array tasks -> a
    java.lang.Object threadLock -> b
    void delay(long) -> a
    com.badlogic.gdx.utils.Timer instance() -> b
    com.badlogic.gdx.utils.Timer$Task schedule(com.badlogic.gdx.utils.Timer$Task,float) -> c
    com.badlogic.gdx.utils.Timer$Task scheduleTask(com.badlogic.gdx.utils.Timer$Task,float) -> d
    com.badlogic.gdx.utils.Timer$Task scheduleTask(com.badlogic.gdx.utils.Timer$Task,float,float,int) -> e
    void start() -> f
    com.badlogic.gdx.utils.Timer$TimerThread thread() -> g
    long update(long,long) -> h
com.badlogic.gdx.utils.Timer$Task -> p.n0$a:
    com.badlogic.gdx.utils.Timer timer -> e
    long executeTimeMillis -> b
    int repeatCount -> d
    com.badlogic.gdx.Application app -> a
    long intervalMillis -> c
com.badlogic.gdx.utils.Timer$TimerThread -> p.n0$b:
    com.badlogic.gdx.utils.Timer instance -> d
    long pauseTimeMillis -> e
    com.badlogic.gdx.utils.Array instances -> c
    com.badlogic.gdx.Files files -> a
    com.badlogic.gdx.Application app -> b
    void dispose() -> a
    void resume() -> b
    void pause() -> c
com.badlogic.gdx.utils.reflect.ArrayReflection -> q.a:
    java.lang.Object newInstance(java.lang.Class,int) -> a
    void set(java.lang.Object,int,java.lang.Object) -> b
com.badlogic.gdx.utils.reflect.ClassReflection -> q.b:
    java.lang.Class forName(java.lang.String) -> a
    com.badlogic.gdx.utils.reflect.Constructor getConstructor(java.lang.Class,java.lang.Class[]) -> b
    com.badlogic.gdx.utils.reflect.Constructor getDeclaredConstructor(java.lang.Class,java.lang.Class[]) -> c
    com.badlogic.gdx.utils.reflect.Field[] getDeclaredFields(java.lang.Class) -> d
    java.lang.String getSimpleName(java.lang.Class) -> e
    boolean isAssignableFrom(java.lang.Class,java.lang.Class) -> f
    boolean isMemberClass(java.lang.Class) -> g
    boolean isStaticClass(java.lang.Class) -> h
    java.lang.Object newInstance(java.lang.Class) -> i
com.badlogic.gdx.utils.reflect.Constructor -> q.c:
    java.lang.reflect.Constructor constructor -> a
    java.lang.Class getDeclaringClass() -> a
    java.lang.Object newInstance(java.lang.Object[]) -> b
    void setAccessible(boolean) -> c
com.badlogic.gdx.utils.reflect.Field -> q.d:
    java.lang.reflect.Field field -> a
    java.lang.Object get(java.lang.Object) -> a
    java.lang.Class getDeclaringClass() -> b
    java.lang.Class getElementType(int) -> c
    java.lang.String getName() -> d
    java.lang.Class getType() -> e
    boolean isAccessible() -> f
    boolean isAnnotationPresent(java.lang.Class) -> g
    boolean isStatic() -> h
    boolean isSynthetic() -> i
    boolean isTransient() -> j
    void set(java.lang.Object,java.lang.Object) -> k
    void setAccessible(boolean) -> l
com.badlogic.gdx.utils.reflect.ReflectionException -> q.e:
com.badlogic.gdx.utils.viewport.ScreenViewport -> r.a:
    float unitsPerPixel -> i
    void update(int,int,boolean) -> n
com.badlogic.gdx.utils.viewport.Viewport -> r.b:
    com.badlogic.gdx.graphics.Camera camera -> a
    int screenWidth -> f
    float worldHeight -> c
    int screenHeight -> g
    float worldWidth -> b
    int screenX -> d
    int screenY -> e
    com.badlogic.gdx.math.Vector3 tmp -> h
    void apply(boolean) -> a
    void calculateScissors(com.badlogic.gdx.math.Matrix4,com.badlogic.gdx.math.Rectangle,com.badlogic.gdx.math.Rectangle) -> b
    com.badlogic.gdx.graphics.Camera getCamera() -> c
    int getScreenHeight() -> d
    int getScreenWidth() -> e
    int getScreenX() -> f
    int getScreenY() -> g
    float getWorldHeight() -> h
    float getWorldWidth() -> i
    void setCamera(com.badlogic.gdx.graphics.Camera) -> j
    void setScreenBounds(int,int,int,int) -> k
    void setWorldSize(float,float) -> l
    com.badlogic.gdx.math.Vector2 unproject(com.badlogic.gdx.math.Vector2) -> m
    void update(int,int,boolean) -> n
com.mygdx.magicstorm.Cards.Attack -> t.a:
    com.badlogic.gdx.graphics.g2d.Sprite sprite -> v
    void positionChanged() -> N
    void scaleChanged() -> P
    void dealDamage(com.mygdx.magicstorm.Enemies.Enemy) -> e0
    void increaseAttack(int) -> h0
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> n
com.mygdx.magicstorm.Cards.Card -> t.b:
    int attack -> t
    int defence -> u
    void addDefence(com.mygdx.magicstorm.hero.Hero) -> d0
    void dealDamage(com.mygdx.magicstorm.Enemies.Enemy) -> e0
    int getAttack() -> f0
    int getDefence() -> g0
    void increaseAttack(int) -> h0
    void act(float) -> i
    void increaseDefence(int) -> i0
    void setAttack(int) -> j0
    void setDefence(int) -> k0
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> n
com.mygdx.magicstorm.Cards.Deck -> t.c:
    com.badlogic.gdx.graphics.g2d.SpriteBatch deckBatch -> y
    com.badlogic.gdx.graphics.g2d.Sprite sprite -> t
    com.badlogic.gdx.graphics.g2d.BitmapFont font -> x
    java.util.ArrayList cards -> z
    int maxDeckSize -> v
    int currentDeckSize -> w
    java.util.Random rand -> A
    java.lang.String currentDeckSizeString -> u
    void positionChanged() -> N
    com.mygdx.magicstorm.Cards.Card drawCard() -> d0
    java.util.ArrayList getCards() -> e0
    int getCurrentDeckSize() -> f0
    java.lang.String getCurrentDeckSizeString() -> g0
    int getMaxDeckSize() -> h0
    int getSize() -> i0
    void setCards(java.util.ArrayList) -> j0
    void setCurrentDeckSizeString(java.lang.String) -> k0
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> n
com.mygdx.magicstorm.Cards.Defence -> t.d:
    com.badlogic.gdx.graphics.g2d.Sprite sprite -> v
    void positionChanged() -> N
    void scaleChanged() -> P
    void addDefence(com.mygdx.magicstorm.hero.Hero) -> d0
    void increaseDefence(int) -> i0
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> n
com.mygdx.magicstorm.Enemies.Enemy -> u.a:
    com.badlogic.gdx.math.Rectangle hpBar -> v
    java.lang.String currentHpString -> y
    com.badlogic.gdx.graphics.g2d.Sprite sprite -> t
    int maxHp -> x
    com.badlogic.gdx.graphics.g2d.BitmapFont font -> z
    com.badlogic.gdx.graphics.glutils.ShapeRenderer shapeRenderer -> u
    int currentHp -> w
    com.badlogic.gdx.graphics.g2d.SpriteBatch hpBatch -> A
    int attackValue -> B
    void attack(com.mygdx.magicstorm.hero.Hero) -> d0
    void die() -> e0
    void draw(com.badlogic.gdx.graphics.g2d.SpriteBatch,float) -> f0
    java.lang.String getAttackValue() -> g0
    boolean isDead() -> h0
    void act(float) -> i
    void setCurrentHpString(java.lang.String) -> i0
    void setHpBarPos(float,float) -> j0
    void takeDamage(int) -> k0
com.mygdx.magicstorm.Enemies.Enemy$1 -> u.a$a:
    com.mygdx.magicstorm.Enemies.Enemy this$0 -> f
com.mygdx.magicstorm.Enemies.Goblin -> u.b:
    com.badlogic.gdx.math.Rectangle hpBar -> F
    com.badlogic.gdx.graphics.g2d.SpriteBatch hpBatch -> K
    java.lang.String currentHpString -> I
    int attackValue -> L
    com.badlogic.gdx.graphics.g2d.Sprite sprite -> C
    int maxHp -> H
    float widthCheck -> E
    com.badlogic.gdx.graphics.g2d.BitmapFont font -> J
    int currentHp -> G
    com.badlogic.gdx.graphics.glutils.ShapeRenderer shapeRenderer -> D
    void positionChanged() -> N
    void attack(com.mygdx.magicstorm.hero.Hero) -> d0
    void die() -> e0
    java.lang.String getAttackValue() -> g0
    boolean isDead() -> h0
    void act(float) -> i
    void setCurrentHpString(java.lang.String) -> i0
    void setHpBarPos(float,float) -> j0
    void takeDamage(int) -> k0
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> n
com.mygdx.magicstorm.Enemies.MagicalConstruct -> u.c:
    com.badlogic.gdx.math.Rectangle hpBar -> F
    com.badlogic.gdx.graphics.g2d.SpriteBatch hpBatch -> K
    java.lang.String currentHpString -> I
    int attackValue -> L
    int currentPhase -> M
    com.badlogic.gdx.graphics.g2d.Sprite sprite -> C
    int maxHp -> H
    float widthCheck -> E
    com.badlogic.gdx.graphics.g2d.BitmapFont font -> J
    int currentHp -> G
    com.badlogic.gdx.graphics.glutils.ShapeRenderer shapeRenderer -> D
    void positionChanged() -> N
    void attack(com.mygdx.magicstorm.hero.Hero) -> d0
    void die() -> e0
    java.lang.String getAttackValue() -> g0
    boolean isDead() -> h0
    void act(float) -> i
    void setCurrentHpString(java.lang.String) -> i0
    void setHpBarPos(float,float) -> j0
    void takeDamage(int) -> k0
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> n
com.mygdx.magicstorm.Enemies.RenegadeMage -> u.d:
    com.badlogic.gdx.math.Rectangle hpBar -> F
    com.badlogic.gdx.graphics.g2d.SpriteBatch hpBatch -> K
    java.lang.String currentHpString -> I
    int attackValue -> L
    int phase -> M
    com.badlogic.gdx.graphics.g2d.Sprite sprite -> C
    int maxHp -> H
    float widthCheck -> E
    com.badlogic.gdx.graphics.g2d.BitmapFont font -> J
    int currentHp -> G
    com.badlogic.gdx.graphics.glutils.ShapeRenderer shapeRenderer -> D
    void positionChanged() -> N
    void attack(com.mygdx.magicstorm.hero.Hero) -> d0
    void die() -> e0
    java.lang.String getAttackValue() -> g0
    boolean isDead() -> h0
    void act(float) -> i
    void setCurrentHpString(java.lang.String) -> i0
    void setHpBarPos(float,float) -> j0
    void takeDamage(int) -> k0
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> n
com.mygdx.magicstorm.MagicStorm -> s.a:
    com.mygdx.magicstorm.Screens.MainMenuScreen mainMenuScreen -> d
    com.badlogic.gdx.graphics.g2d.SpriteBatch batch -> b
    com.badlogic.gdx.graphics.g2d.BitmapFont font -> c
    boolean touchDragged(int,int,int) -> A
    boolean mouseMoved(int,int) -> H
    boolean keyUp(int) -> K
    boolean touchUp(int,int,int,int) -> M
    void dispose() -> a
    void create() -> e
    void render() -> f
    boolean scrolled(float,float) -> j
    boolean keyTyped(char) -> n
    boolean keyDown(int) -> s
    boolean touchDown(int,int,int,int) -> u
com.mygdx.magicstorm.Rewards.AttackReward -> v.a:
    com.badlogic.gdx.graphics.g2d.Sprite sprite -> t
    void positionChanged() -> N
    void rewardEffect(com.mygdx.magicstorm.hero.Hero) -> d0
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> n
com.mygdx.magicstorm.Rewards.DefenceReward -> v.b:
    com.badlogic.gdx.graphics.g2d.Sprite sprite -> t
    void positionChanged() -> N
    void rewardEffect(com.mygdx.magicstorm.hero.Hero) -> d0
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> n
com.mygdx.magicstorm.Rewards.HpReward -> v.c:
    com.badlogic.gdx.graphics.g2d.Sprite sprite -> t
    void positionChanged() -> N
    void rewardEffect(com.mygdx.magicstorm.hero.Hero) -> d0
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> n
com.mygdx.magicstorm.Rewards.Reward -> v.d:
com.mygdx.magicstorm.Screens.DefeatScreen -> w.a:
    com.mygdx.magicstorm.MagicStorm game -> a
    com.badlogic.gdx.scenes.scene2d.Stage stage -> c
    com.badlogic.gdx.graphics.OrthographicCamera camera -> b
    com.badlogic.gdx.scenes.scene2d.ui.Skin skin -> d
    com.badlogic.gdx.scenes.scene2d.ui.TextButton restartButton -> f
    com.badlogic.gdx.scenes.scene2d.ui.Table table -> e
    void render(float) -> a
    void resume() -> b
    void pause() -> c
    void resize(int,int) -> d
    void hide() -> e
    void show() -> f
    void dispose() -> g
com.mygdx.magicstorm.Screens.DefeatScreen$1 -> w.a$a:
    com.mygdx.magicstorm.Screens.DefeatScreen this$0 -> p
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> l
com.mygdx.magicstorm.Screens.MainGameScreen -> w.b:
    int easyEnemies -> l
    com.mygdx.magicstorm.Screens.MainPauseScreen pauseScreen -> f
    boolean availableRewards -> q
    int selectedCardY -> C
    com.mygdx.magicstorm.Screens.VictoryScreen victoryScreen -> g
    java.util.ArrayList enemies -> o
    com.mygdx.magicstorm.Cards.Deck deck -> H
    com.mygdx.magicstorm.Rewards.AttackReward attackReward -> I
    java.util.Random rand -> G
    com.mygdx.magicstorm.Cards.Card sampleCard -> y
    boolean startOfBattle -> E
    int handSize -> w
    int cardNo -> u
    com.mygdx.magicstorm.Screens.MainGameScreen$State state -> L
    com.mygdx.magicstorm.MagicStorm game -> a
    int hardEnemies -> m
    boolean cardSelected -> j
    int floor -> k
    com.mygdx.magicstorm.Rewards.DefenceReward defenceReward -> J
    com.mygdx.magicstorm.Screens.MainGameScreen mainGameScreen -> c
    java.util.ArrayList cards -> d
    com.mygdx.magicstorm.Enemies.Enemy currentEnemy -> p
    float cardHeight -> A
    int selectedCardX -> B
    boolean selectingRewards -> r
    com.badlogic.gdx.graphics.g2d.SpriteBatch batch -> i
    com.mygdx.magicstorm.Cards.Card selectedCard -> t
    float cardWidth -> z
    com.mygdx.magicstorm.Cards.Card drawnCard -> v
    int spaceAtEachSide -> x
    com.mygdx.magicstorm.Rewards.HpReward hpReward -> K
    boolean touched -> e
    com.badlogic.gdx.scenes.scene2d.Stage stage -> b
    boolean startOfTurn -> F
    com.badlogic.gdx.scenes.scene2d.Group group -> n
    com.mygdx.magicstorm.hero.Hero hero -> s
    com.mygdx.magicstorm.Screens.DefeatScreen defeatScreen -> h
    boolean enemyTurn -> D
    void render(float) -> a
    void resume() -> b
    void pause() -> c
    void resize(int,int) -> d
    void hide() -> e
    void show() -> f
    com.mygdx.magicstorm.Enemies.Enemy access$000(com.mygdx.magicstorm.Screens.MainGameScreen) -> g
    com.mygdx.magicstorm.Cards.Deck copyDeck(com.mygdx.magicstorm.Cards.Deck) -> h
    void drawCard(int) -> i
    void shuffle() -> j
com.mygdx.magicstorm.Screens.MainGameScreen$1 -> w.b$a:
    com.mygdx.magicstorm.Screens.MainGameScreen this$0 -> b
    com.badlogic.gdx.scenes.scene2d.Actor val$hitActor -> a
com.mygdx.magicstorm.Screens.MainGameScreen$2 -> w.b$b:
    com.mygdx.magicstorm.Screens.MainGameScreen this$0 -> b
    com.badlogic.gdx.scenes.scene2d.Actor val$hitActor -> a
com.mygdx.magicstorm.Screens.MainGameScreen$3 -> w.b$c:
    com.mygdx.magicstorm.Screens.MainGameScreen this$0 -> g
    com.mygdx.magicstorm.hero.Hero val$hero -> f
com.mygdx.magicstorm.Screens.MainGameScreen$4 -> w.b$d:
    com.badlogic.gdx.scenes.scene2d.Actor val$startTurn -> f
    com.mygdx.magicstorm.Screens.MainGameScreen this$0 -> h
    com.mygdx.magicstorm.hero.Hero val$hero -> g
com.mygdx.magicstorm.Screens.MainGameScreen$5 -> w.b$e:
    int[] $SwitchMap$com$mygdx$magicstorm$Screens$MainGameScreen$State -> a
com.mygdx.magicstorm.Screens.MainGameScreen$State -> w.b$f:
    com.mygdx.magicstorm.Screens.MainGameScreen$State DEFEAT -> f
    com.mygdx.magicstorm.Screens.MainGameScreen$State RESUME -> g
    com.mygdx.magicstorm.Screens.MainGameScreen$State[] $VALUES -> h
    com.mygdx.magicstorm.Screens.MainGameScreen$State PLAYERTURN -> b
    com.mygdx.magicstorm.Screens.MainGameScreen$State STARTTURN -> c
    com.mygdx.magicstorm.Screens.MainGameScreen$State ENEMYTURN -> d
    com.mygdx.magicstorm.Screens.MainGameScreen$State VICTORY -> e
    com.mygdx.magicstorm.Screens.MainGameScreen$State PAUSE -> a
    com.mygdx.magicstorm.Screens.MainGameScreen$State[] $values() -> a
com.mygdx.magicstorm.Screens.MainMenuScreen -> w.c:
    com.badlogic.gdx.graphics.g2d.Sprite sprite -> h
    com.mygdx.magicstorm.MagicStorm game -> a
    com.badlogic.gdx.scenes.scene2d.Stage stage -> c
    com.badlogic.gdx.graphics.OrthographicCamera camera -> b
    com.badlogic.gdx.scenes.scene2d.ui.Skin skin -> d
    com.badlogic.gdx.scenes.scene2d.ui.TextButton startButton -> f
    com.badlogic.gdx.graphics.g2d.SpriteBatch batch -> g
    com.badlogic.gdx.scenes.scene2d.ui.Table table -> e
    void render(float) -> a
    void resume() -> b
    void pause() -> c
    void resize(int,int) -> d
    void hide() -> e
    void show() -> f
    void dispose() -> g
com.mygdx.magicstorm.Screens.MainMenuScreen$1 -> w.c$a:
    com.mygdx.magicstorm.MagicStorm val$game -> p
    com.mygdx.magicstorm.Screens.MainMenuScreen this$0 -> q
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> l
com.mygdx.magicstorm.Screens.MainPauseScreen -> w.d:
    com.badlogic.gdx.graphics.g2d.SpriteBatch batch -> i
    com.mygdx.magicstorm.MagicStorm game -> a
    com.badlogic.gdx.graphics.g2d.Sprite sprite -> j
    com.badlogic.gdx.scenes.scene2d.Stage stage -> e
    com.mygdx.magicstorm.hero.Hero hero -> b
    com.badlogic.gdx.graphics.OrthographicCamera camera -> c
    com.mygdx.magicstorm.Screens.MainGameScreen gameScreen -> d
    com.badlogic.gdx.scenes.scene2d.ui.Skin skin -> f
    com.badlogic.gdx.scenes.scene2d.ui.TextButton resumeButton -> h
    com.badlogic.gdx.scenes.scene2d.ui.Table table -> g
    void render(float) -> a
    void resume() -> b
    void pause() -> c
    void resize(int,int) -> d
    void hide() -> e
    void show() -> f
    void dispose() -> g
com.mygdx.magicstorm.Screens.MainPauseScreen$1 -> w.d$a:
    com.mygdx.magicstorm.Screens.MainPauseScreen this$0 -> p
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> l
com.mygdx.magicstorm.Screens.UltimateSelectScreen -> w.e:
    com.mygdx.magicstorm.MagicStorm game -> a
    com.badlogic.gdx.scenes.scene2d.Stage stage -> c
    com.badlogic.gdx.graphics.g2d.Sprite sprite -> f
    com.badlogic.gdx.graphics.OrthographicCamera camera -> b
    com.badlogic.gdx.scenes.scene2d.ui.Skin skin -> d
    com.badlogic.gdx.graphics.g2d.SpriteBatch batch -> e
    com.mygdx.magicstorm.hero.Hero hero -> g
    void render(float) -> a
    void resume() -> b
    void pause() -> c
    void resize(int,int) -> d
    void hide() -> e
    void show() -> f
    void dispose() -> g
com.mygdx.magicstorm.Screens.VictoryScreen -> w.f:
    com.mygdx.magicstorm.MagicStorm game -> a
    com.badlogic.gdx.scenes.scene2d.Stage stage -> c
    com.badlogic.gdx.graphics.OrthographicCamera camera -> b
    com.badlogic.gdx.scenes.scene2d.ui.Skin skin -> d
    com.badlogic.gdx.scenes.scene2d.ui.TextButton restartButton -> f
    com.badlogic.gdx.scenes.scene2d.ui.Table table -> e
    void render(float) -> a
    void resume() -> b
    void pause() -> c
    void resize(int,int) -> d
    void hide() -> e
    void show() -> f
    void dispose() -> g
com.mygdx.magicstorm.Screens.VictoryScreen$1 -> w.f$a:
    com.mygdx.magicstorm.Screens.VictoryScreen this$0 -> p
    void clicked(com.badlogic.gdx.scenes.scene2d.InputEvent,float,float) -> l
com.mygdx.magicstorm.UltimateSkills.UltimateArmorGain -> x.a:
    com.badlogic.gdx.graphics.g2d.Sprite sprite -> x
    java.lang.String progressString -> z
    int maxCounter -> y
    int progress -> w
    void positionChanged() -> N
    void effect(com.mygdx.magicstorm.hero.Hero,com.mygdx.magicstorm.Enemies.Enemy) -> d0
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> n
com.mygdx.magicstorm.UltimateSkills.UltimateDamageDone -> x.b:
    com.badlogic.gdx.graphics.g2d.Sprite sprite -> x
    java.lang.String progressString -> z
    int maxCounter -> y
    int progress -> w
    void positionChanged() -> N
    void effect(com.mygdx.magicstorm.hero.Hero,com.mygdx.magicstorm.Enemies.Enemy) -> d0
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> n
com.mygdx.magicstorm.UltimateSkills.UltimateSkill -> x.c:
    java.lang.String progressString -> v
    int progress -> t
    int maxCounter -> u
    void effect(com.mygdx.magicstorm.hero.Hero,com.mygdx.magicstorm.Enemies.Enemy) -> d0
    int getMaxCounter() -> e0
    int getProgress() -> f0
    java.lang.String getProgressString() -> g0
    void increaseProgress(int) -> h0
    boolean isReady() -> i0
    void setMaxCounter(int) -> j0
    void setProgress(int) -> k0
    void setProgressString(java.lang.String) -> l0
com.mygdx.magicstorm.hero.Hero -> y.a:
    com.badlogic.gdx.graphics.g2d.BitmapFont font -> u
    java.lang.String currentArmorString -> F
    com.badlogic.gdx.math.Rectangle hpBar -> x
    com.badlogic.gdx.math.Rectangle ultimateBar -> z
    float widthCheck -> H
    com.badlogic.gdx.math.Rectangle armorBar -> y
    int currentArmor -> D
    int maxArmor -> E
    int maxHp -> B
    com.badlogic.gdx.graphics.glutils.ShapeRenderer shapeRenderer -> w
    int currentHp -> A
    com.mygdx.magicstorm.Cards.Deck deck -> J
    com.mygdx.magicstorm.UltimateSkills.UltimateSkill ultimateSkill -> I
    com.badlogic.gdx.graphics.g2d.Sprite sprite -> t
    java.lang.String currentHpString -> C
    com.badlogic.gdx.graphics.g2d.SpriteBatch hpBatch -> v
    com.mygdx.magicstorm.hero.Mana mana -> G
    void positionChanged() -> N
    void die() -> d0
    void gainArmor(int) -> e0
    void gainHp(int) -> f0
    com.mygdx.magicstorm.Cards.Deck getDeck() -> g0
    int getMaxHp() -> h0
    void act(float) -> i
    int getUltimateMaxCounter() -> i0
    com.mygdx.magicstorm.UltimateSkills.UltimateSkill getUltimateSkill() -> j0
    boolean isDead() -> k0
    void progressUltimate(int) -> l0
    void resetUltimate() -> m0
    void draw(com.badlogic.gdx.graphics.g2d.Batch,float) -> n
    void setArmor(int) -> n0
    void setArmorBarPos(float,float) -> o0
    void setHpBarPos(float,float) -> p0
    void setMana(int) -> q0
    void setMaxHp(int) -> r0
    void setUltimateBarPos(float,float) -> s0
    void setUltimateProgress(int) -> t0
    void setUltimateSkill(com.mygdx.magicstorm.UltimateSkills.UltimateSkill) -> u0
    void takeDamage(int) -> v0
com.mygdx.magicstorm.hero.Hero$1 -> y.a$a:
    com.mygdx.magicstorm.hero.Hero this$0 -> f
com.mygdx.magicstorm.hero.Mana -> y.b:
    int maxMana -> b
    java.lang.String currentManaString -> c
    int currentMana -> a
    int getCurrentMana() -> a
    java.lang.String getCurrentManaString() -> b
    int getMaxMana() -> c
    void setCurrentMana(int) -> d
    void setCurrentManaString(java.lang.String) -> e
